/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/chip-8.js":
/*!***********************!*\
  !*** ./src/chip-8.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Made with a loooot of help from this excellent resource: http://devernay.free.fr/hacks/chip8/C8TECH10.HTM\n/* harmony default export */ __webpack_exports__[\"default\"] = ((keyboard, render, sound) => {\n  // CHIP-8 Interpreter\n  const WORD_SIZE = 8\n\n  // It has 16 8-bit data registers. V[0xF] is the carry register.\n  let vRegisters = new Uint8Array(16)\n\n  // It was originally designed to work on 4k computers, so lets give ourselves 4k of memory\n  // 0x0 -> 0x1FF is used to store the system font (it was originally used to store the interpreter data, back when it\n  // was ran on 4k systems)\n  // 0x200 -> 0xFFF is used to store the program data\n  let memory = new Uint8Array(4096)\n\n  // Copied from CowGood's font set\n  const fonts = [\n    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0\n    0x20, 0x60, 0x20, 0x20, 0x70, // 1\n    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2\n    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3\n    0x90, 0x90, 0xF0, 0x10, 0x10, // 4\n    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5\n    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6\n    0xF0, 0x10, 0x20, 0x40, 0x40, // 7\n    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8\n    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9\n    0xF0, 0x90, 0xF0, 0x90, 0x90, // A\n    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B\n    0xF0, 0x80, 0x80, 0x80, 0xF0, // C\n    0xE0, 0x90, 0x90, 0x90, 0xE0, // D\n    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E\n    0xF0, 0x80, 0xF0, 0x80, 0x80 // F\n  ]\n\n  memory.set(fonts, 0)\n\n  // There are 2 timers, a delay timer and a sound timer, both decrease to 0 at a rate of 60Hz,\n  // once at 0 they stay there\n  let delayTimer = 0\n\n  // When the sound timer hits 0, a monotone sound is played.\n  let soundTimer = 0\n\n  // And of course a (16-bit) program counter, starting at... 0x200 (where the program is loaded in!)\n  let pc = 0x200\n\n  // It also has a 16-bit register, usually used for addressing memory\n  let iRegister = pc\n\n  // A stack pointer, allows us to have function calls.\n  let sp = 0\n\n  // The stack. Documentation says it's 16 deep, but apparently only 10 are ever used?\n  let stack = new Array(16)\n\n  // It utilises a 64x32 pixel display... we will get the chip-8 to write to these values, and in our `emulator` code,\n  // we will write these values to a screen. Simple! (should be!).\n  const DISPLAY_WIDTH = 64\n  const DISPLAY_HEIGHT = 32\n  let display = new Array(DISPLAY_WIDTH).fill().map(_ => new Array(DISPLAY_HEIGHT).fill(0))\n\n  let drawFlag = true\n  let animationFrame\n\n  function setMemory (file, start) {\n    memory.set(file, start)\n  }\n\n  function getDisplay () {\n    return display\n  }\n\n  function start () {\n    console.log('Starting...')\n    let lastTimeUpdated = Date.now()\n    const cpuSpeed = 1000 / 500 // 500Mhz\n    animationFrame = window.requestAnimationFrame(function loop () {\n      // cycle the CPU \"many\" times, depending on how long the draw loop took\n      const now = Date.now()\n      const diff = now - lastTimeUpdated\n      const cycles = Math.floor(diff / cpuSpeed)\n      for (var i = 0; i < cycles; i += 1) {\n        cycle()\n      }\n\n      if (drawFlag) {\n        render()\n        drawFlag = false\n      }\n\n      lastTimeUpdated = now\n\n      animationFrame = window.requestAnimationFrame(loop)\n    })\n  }\n\n  function reset () {\n    window.cancelAnimationFrame(animationFrame)\n    memory = new Uint8Array(4096)\n    vRegisters = new Uint8Array(16)\n    memory.set(fonts, 0)\n    display = new Array(DISPLAY_WIDTH).fill().map(_ => new Array(DISPLAY_HEIGHT).fill(0))\n    pc = 0x200\n    stack = new Array(16)\n    drawFlag = true\n    delayTimer = 0\n    soundTimer = 0\n    iRegister = pc\n  }\n\n  // does a cpu cycle innit.\n  let lastTimeDecremented = 0\n  function cycle () {\n    const currentTime = Date.now()\n    const dT = currentTime - lastTimeDecremented\n    const timerRefreshRate = 1000 / 60\n    if (dT >= timerRefreshRate) {\n      // decrement delayTimer at a rate of 60Hz\n      if (delayTimer > 0) {\n        delayTimer -= 1\n      }\n\n      if (soundTimer > 0) {\n        soundTimer -= 1\n        if (soundTimer === 0) {\n          sound.play()\n        }\n      }\n\n      lastTimeDecremented = currentTime\n    }\n\n    const inst = fetch()\n\n    // decode & execute (i'm too lazy to have them do separately, feels like a waste? We'll see...)\n    decodeAndExecute(inst)\n  }\n\n  // fetching from memory takes twoooo cycles, cos it's an 8-bit bus,\n  // but each instruction is 16-bits long.\n  function fetch () {\n    const inst = (memory[pc] << 8) | memory[pc + 1]\n    pc += 2\n\n    return inst\n  }\n\n  // aight we got a hex value now we need to look up what that means exactly\n  function decodeAndExecute (inst) {\n    // Many of the instructions follow the structure below, so to make my life simpler, I will calculate these values\n    // from the instruction We are using bitmasking to get these values. If you don't quite get what's happening here,\n    // look up https://en.wikipedia.org/wiki/Mask_(computing)\n\n    const nnn = inst & 0x0FFF // nnn or addr - A 12-bit value, the lowest 12 bits of the instruction\n    const n = inst & 0x000F // n or nibble - A 4-bit value, the lowest 4 bits of the instruction\n    const x = (inst & 0x0F00) >> 8 // x - A 4-bit value, the lower 4 bits of the high byte of the instructionction\n    const y = (inst & 0x00F0) >> 4// y - A 4-bit value, the upper 4 bits of the low byte of the instru\n    const kk = inst & 0x00FF // kk or byte - An 8-bit value, the lowest 8 bits of the instruction\n\n    // gonna split this into 'macro level opcodes' and 'micro level opcodes', as the instructions can be indexed by the\n    // highest byte first, and then after that we can decide what to do...\n    const highByte = inst & 0xF000\n    // We... could use a switch statement here, but that would be insane, right? How about a map instead?\n    const macroOpcodes = {\n      0x0000: clearAndReturnOpcodes,\n      0x1000: jump,\n      0x2000: callSubroutine,\n      0x3000: skipIfVxkk,\n      0x4000: skipIfNotVxkk,\n      0x5000: skipIfVxVy,\n      0x6000: loadVxVal,\n      0x7000: addVxVal,\n      0x8000: settingFuncs,\n      0x9000: skipIfNotVxVy,\n      0xA000: loadIAddr,\n      0xB000: jumpV0Offset,\n      0xC000: setVxRandom,\n      0xD000: draw,\n      0xE000: skipKey,\n      0xF000: registerManipulation\n    }\n\n    const macroOpcode = macroOpcodes[highByte]\n\n    macroOpcode({ nnn, n, x, y, kk }) // Yes, very ineffecient right now\n  }\n\n  // 0x0000\n  function clearAndReturnOpcodes (inst) {\n    // is the last bit set? if it is, it's the 'RET' function, otherwise it's the 'CLS' function\n    if (inst.nnn & 0x00F) {\n      returnFromSub() // 0x00EE\n    } else {\n      clearScreen() // 0x00E0\n    }\n\n    // 00E0 - CLS -> Clear the screen\n    function clearScreen () {\n      for (var x = 0; x < display.length; x += 1) {\n        for (var y = 0; y < display[x].length; y += 1) {\n          display[x][y] = 0\n        }\n      }\n    }\n\n    // 00EE - RET\n    // The interpreter sets the program counter to the address at the top of the stack, then subtracts 1 from the stack\n    // pointer. We're doing it the other way around (subtract, THEN set), because otherwise our 'stack's' (which is an\n    // array) first element is never set (stack[0] will never be used)\n    function returnFromSub () {\n      sp -= 1\n      pc = stack[sp]\n    }\n  }\n\n  // 1nnn - JP addr -> Sets pc to nnn\n  function jump (inst) {\n    pc = inst.nnn\n  }\n\n  // 2nnn - CALL addr\n  // Call subroutine at nnn.\n  // The interpreter increments the stack pointer, then puts the current PC on the top of the stack. The PC is then set\n  // to nnn. We're doing this the other way around (set, then increment), see 00EE for more info.\n  function callSubroutine (inst) {\n    stack[sp] = pc\n    sp += 1\n    pc = inst.nnn\n  }\n\n  // 3xkk - SE Vx, byte -> The interpreter compares register Vx to kk, and if they are equal, increments pc by 2.\n  function skipIfVxkk (inst) { // 5xy0 - SE Vx, Vy\n    if (vRegisters[inst.x] === inst.kk) {\n      pc += 2\n    }\n  }\n\n  // 4xkk - SNE Vx, byte\n  // Skip next instruction if Vx != kk.\n  // The interpreter compares register Vx to kk, and if they are not equal, increments the program counter by 2.\n  function skipIfNotVxkk (inst) {\n    if (vRegisters[inst.x] !== inst.kk) {\n      pc += 2\n    }\n  }\n\n  // 5xy0 - SE Vx, Vy\n  // Skip next instruction if Vx = Vy.\n  // The interpreter compares register Vx to register Vy, and if they are equal, increments the program counter by 2.\n  function skipIfVxVy (inst) {\n    if (vRegisters[inst.x] === vRegisters[inst.y]) {\n      pc += 2\n    }\n  }\n\n  // 6xkk - LD Vx, byte\n  // Set Vx = kk.\n  // The interpreter puts the value kk into register Vx.\n  function loadVxVal (inst) {\n    vRegisters[inst.x] = inst.kk\n  }\n\n  // 0x7000\n  // Set Vx = Vx + kk.\n  // Adds the value kk to the value of register Vx, then stores the result in Vx.\n  function addVxVal (inst) {\n    vRegisters[inst.x] = vRegisters[inst.x] + inst.kk\n  }\n\n  // 0x8000\n  function settingFuncs (inst) {\n    const microOpCodes = {\n      0x0: loadVxVy,\n      0x1: vXOrVy,\n      0x3: VxXorVy,\n      0x2: vXAndVy,\n      0x4: vXAddVy,\n      0x5: vXSubVy,\n      0x6: shiftRight,\n      0x7: vYSubVx,\n      0xE: shiftLeft\n    }\n\n    // 8xy0 - LD Vx, Vy -> Vx = Vy\n    function loadVxVy () {\n      vRegisters[inst.x] = vRegisters[inst.y]\n    }\n\n    // 8xy1 - OR Vx, Vy -> Vx = Vx | Vy\n    function vXOrVy () {\n      vRegisters[inst.x] = vRegisters[inst.x] | vRegisters[inst.y]\n    }\n\n    // 8xy2 - AND Vx, Vy -> Vx = Vx & Vy\n    function vXAndVy () {\n      vRegisters[inst.x] = vRegisters[inst.x] & vRegisters[inst.y]\n    }\n\n    // 8xy3 - XOR Vx, Vy -> Set Vx = Vx XOR Vy.\n    function VxXorVy () {\n      vRegisters[inst.x] = vRegisters[inst.x] ^ vRegisters[inst.y]\n    }\n\n    // 8xy4 - ADD Vx, Vy -> Vx = Vx + Vy -> Vx = Vx + Vy, set VF = carry.\n    function vXAddVy () {\n      const result = vRegisters[inst.x] + vRegisters[inst.y]\n\n      if (result > 0xFF) {\n        vRegisters[0xF] = 1\n      } else {\n        vRegisters[0xF] = 0\n      }\n\n      vRegisters[inst.x] = result & 0xFF\n    }\n\n    // 8xy5 - SUB Vx, Vy\n    // Set Vx = Vx - Vy, set VF = NOT borrow.\n    // If Vx > Vy, then VF is set to 1, otherwise 0. Then Vy is subtracted from Vx, and the results stored in Vx.\n    function vXSubVy () {\n      if (vRegisters[inst.x] > vRegisters[inst.y]) {\n        vRegisters[0xF] = 1\n      } else {\n        vRegisters[0xF] = 0\n      }\n\n      vRegisters[inst.x] = (vRegisters[inst.x] - vRegisters[inst.y]) & 0xFF\n    }\n\n    // 8xy6 - SHR Vx {, Vy} -> V[0xF] = Vx & 0x1. Set Vx = Vx >> 1\n    function shiftRight () {\n      vRegisters[0xF] = vRegisters[inst.x] & 0b1\n      vRegisters[inst.x] = vRegisters[inst.x] >> 1\n    }\n\n    // 8xy7 - SUBN Vx, Vy -> Set Vx = Vy - Vx, set VF = NOT borrow.\n    function vYSubVx () {\n      if (vRegisters[inst.y] > vRegisters[inst.x]) {\n        vRegisters[0xF] = 1\n      } else {\n        vRegisters[0xF] = 0\n      }\n\n      vRegisters[inst.x] = vRegisters[inst.y] - vRegisters[inst.x]\n    }\n\n    // 8xyE - SHL Vx {, Vy} -> V[0xF] = 1 if Vx >= 0x80, else 0. Then Vx = Vx << 1.\n    function shiftLeft () {\n      if (vRegisters[inst.x] & 0b10000000) {\n        vRegisters[0xF] = 1\n      } else {\n        vRegisters[0xF] = 0\n      }\n\n      vRegisters[inst.x] = vRegisters[inst.x] << 1\n    }\n\n    if (!microOpCodes[inst.n]) {\n      console.error(`Missing instruction: ${inst.n.toString(16)}`)\n    }\n\n    microOpCodes[inst.n]()\n  }\n\n  // 9xy0 - SNE Vx, Vy -> Skip next instruction if Vx != Vy.\n  function skipIfNotVxVy (inst) {\n    if (vRegisters[inst.x] !== vRegisters[inst.y]) {\n      pc += 2\n    }\n  }\n\n  // 0xA000 -> i = nnn\n  function loadIAddr (inst) {\n    iRegister = inst.nnn\n  }\n\n  // Bnnn - JP V0, addr -> pc = nnn + V0.\n  function jumpV0Offset (inst) {\n    pc = inst.nnn + vRegisters[0]\n  }\n\n  // Cxkk - RND Vx, byte -> Set Vx = random byte AND kk.\n  function setVxRandom (inst) {\n    const random = Math.floor(Math.random(1) * 255)\n    vRegisters[inst.x] = random & inst.kk\n  }\n\n  // Dxyn - DRW Vx, Vy, nibble\n  // Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.\n  // The interpreter reads n bytes from memory, starting at the address stored in I.\n  // These bytes are then displayed as sprites on screen at coordinates (Vx, Vy).\n  // Sprites are XORed onto the existing screen.\n  // If this causes any pixels to be erased, VF is set to 1, otherwise it is set to 0.\n  // If the sprite is positioned so part of it is outside the coordinates of the display, i t wraps around to the\n  // opposite side of the screen.\n  function draw (inst) {\n    let x = vRegisters[inst.x]\n    let y = vRegisters[inst.y]\n    let iAddr = iRegister\n    vRegisters[0xF] = 0\n\n    for (var i = 0; i < inst.n; i += 1) {\n      const newY = (y + i) % DISPLAY_HEIGHT\n\n      const line = memory[iAddr]\n      iAddr += 1\n\n      for (var j = 0; j < WORD_SIZE; j += 1) {\n        const newX = (x + j) % DISPLAY_WIDTH\n\n        const bitmask = 0b00000001 << (WORD_SIZE - 1 - j)\n        const pixel = (line & bitmask) >> (WORD_SIZE - 1 - j)\n\n        const currentPixel = display[newX][newY]\n        const newPixel = currentPixel ^ pixel\n\n        display[newX][newY] = newPixel\n\n        if (currentPixel > newPixel) {\n          vRegisters[0xF] = 1\n        }\n      }\n    }\n\n    drawFlag = true\n  }\n\n  // 0xE000\n  function skipKey (inst) {\n    // Ex9E - SKP Vx -> Skip next instruction if key with the value of Vx is pressed.\n    if (inst.kk === 0x9E) {\n      const isKeyPressed = keyboard.get(vRegisters[inst.x])\n      if (isKeyPressed) {\n        pc += 2\n      }\n      return\n    }\n\n    // ExA1 - SKNP Vx\n    // Skip next instruction if key with the value of Vx is not pressed.\n    // Checks the keyboard, and if the key corresponding to the value of Vx is currently in the up position, PC is\n    // increased by 2.\n    if (inst.kk === 0xA1) {\n      const isKeyPressed = keyboard.get(vRegisters[inst.x])\n      if (!isKeyPressed) {\n        pc += 2\n      }\n    }\n  }\n\n  // 0xF000\n  function registerManipulation (inst) {\n    const microOpCodes = {\n      0x07: loadDelayTimer,\n      0x0A: waitForKeyPress,\n      0x15: setDelayTimer,\n      0x18: setSoundTimer,\n      0x1E: addIVx,\n      0x29: loadIVx,\n      0x33: storeBcd,\n      0x55: loadIV0ToVx,\n      0x65: loadV0ToVxI\n    }\n\n    // Fx07 - LD Vx, DT -> The value of DT is placed into Vx.\n    function loadDelayTimer () {\n      vRegisters[inst.x] = delayTimer\n    }\n\n    // Fx15 - LD DT, Vx -> DT is set equal to the value of Vx.\n    function setDelayTimer () {\n      delayTimer = vRegisters[inst.x]\n    }\n\n    // Fx1E - ADD I, Vx -> Set I = I + Vx.\n    function addIVx () {\n      const value = iRegister + vRegisters[inst.x]\n\n      if (value > 0xFFF) {\n        vRegisters[0xF] = 1\n      } else {\n        vRegisters[0xF] = 0\n      }\n\n      iRegister = value & 0xFFF\n    }\n\n    // Fx29 - LD F, Vx -> Set I = location of sprite for digit Vx.\n    function loadIVx () {\n      iRegister = vRegisters[inst.x] * 5\n    }\n\n    // Fx33 - LD B, Vx\n    // Store BCD representation of Vx in memory locations I, I+1, and I+2.\n    // The interpreter takes the decimal value of Vx, and places the hundreds digit in\n    // memory at location in I, the tens digit at location I+1, and the ones digit at location I+2.\n    function storeBcd () {\n      const dec = vRegisters[inst.x]\n\n      // For a given value, say 234\n      memory[iRegister] = Math.floor(dec / 100) // Gives us 2\n      memory[iRegister + 1] = Math.floor(dec / 10) % 10 // Gives us 3\n      memory[iRegister + 2] = dec % 10 // Gives us 4\n    }\n\n    // Fx55 - LD [I], Vx -> V[0]...V[x] => memory[I]...memory[I + x]\n    function loadIV0ToVx () {\n      for (let i = 0; i <= inst.x; i += 1) {\n        memory[iRegister + i] = vRegisters[i]\n      }\n    }\n\n    // Fx65 - LD Vx, [I] -> The interpreter reads values from memory starting at location I into registers V0 through Vx.\n    function loadV0ToVxI () {\n      for (let i = 0; i <= inst.x; i += 1) {\n        vRegisters[i] = memory[iRegister + i]\n      }\n    }\n\n    // Fx0A - LD Vx, K\n    // Wait for a key press, store the value of the key in Vx.\n    // All execution stops until a key is pressed, then the value of that key is stored in Vx.\n    function waitForKeyPress () {\n      const keyPressed = keyboard.getAny()\n\n      if (!keyPressed) {\n        pc -= 2 // keep looping until a key is pressed\n\n        return\n      }\n\n      vRegisters[inst.x] = keyPressed\n\n      return keyPressed\n    }\n\n    // Fx18 - LD ST, Vx -> Set sound timer = Vx.\n    function setSoundTimer () {\n      soundTimer = vRegisters[inst.x]\n    }\n\n    return microOpCodes[inst.kk]()\n  }\n\n  return {\n    getDisplay,\n    setMemory,\n    start,\n    reset\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2hpcC04LmpzPzZmZTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Iiwic291cmNlc0NvbnRlbnQiOlsiLy8gTWFkZSB3aXRoIGEgbG9vb290IG9mIGhlbHAgZnJvbSB0aGlzIGV4Y2VsbGVudCByZXNvdXJjZTogaHR0cDovL2RldmVybmF5LmZyZWUuZnIvaGFja3MvY2hpcDgvQzhURUNIMTAuSFRNXG5leHBvcnQgZGVmYXVsdCAoa2V5Ym9hcmQsIHJlbmRlciwgc291bmQpID0+IHtcbiAgLy8gQ0hJUC04IEludGVycHJldGVyXG4gIGNvbnN0IFdPUkRfU0laRSA9IDhcblxuICAvLyBJdCBoYXMgMTYgOC1iaXQgZGF0YSByZWdpc3RlcnMuIFZbMHhGXSBpcyB0aGUgY2FycnkgcmVnaXN0ZXIuXG4gIGxldCB2UmVnaXN0ZXJzID0gbmV3IFVpbnQ4QXJyYXkoMTYpXG5cbiAgLy8gSXQgd2FzIG9yaWdpbmFsbHkgZGVzaWduZWQgdG8gd29yayBvbiA0ayBjb21wdXRlcnMsIHNvIGxldHMgZ2l2ZSBvdXJzZWx2ZXMgNGsgb2YgbWVtb3J5XG4gIC8vIDB4MCAtPiAweDFGRiBpcyB1c2VkIHRvIHN0b3JlIHRoZSBzeXN0ZW0gZm9udCAoaXQgd2FzIG9yaWdpbmFsbHkgdXNlZCB0byBzdG9yZSB0aGUgaW50ZXJwcmV0ZXIgZGF0YSwgYmFjayB3aGVuIGl0XG4gIC8vIHdhcyByYW4gb24gNGsgc3lzdGVtcylcbiAgLy8gMHgyMDAgLT4gMHhGRkYgaXMgdXNlZCB0byBzdG9yZSB0aGUgcHJvZ3JhbSBkYXRhXG4gIGxldCBtZW1vcnkgPSBuZXcgVWludDhBcnJheSg0MDk2KVxuXG4gIC8vIENvcGllZCBmcm9tIENvd0dvb2QncyBmb250IHNldFxuICBjb25zdCBmb250cyA9IFtcbiAgICAweEYwLCAweDkwLCAweDkwLCAweDkwLCAweEYwLCAvLyAwXG4gICAgMHgyMCwgMHg2MCwgMHgyMCwgMHgyMCwgMHg3MCwgLy8gMVxuICAgIDB4RjAsIDB4MTAsIDB4RjAsIDB4ODAsIDB4RjAsIC8vIDJcbiAgICAweEYwLCAweDEwLCAweEYwLCAweDEwLCAweEYwLCAvLyAzXG4gICAgMHg5MCwgMHg5MCwgMHhGMCwgMHgxMCwgMHgxMCwgLy8gNFxuICAgIDB4RjAsIDB4ODAsIDB4RjAsIDB4MTAsIDB4RjAsIC8vIDVcbiAgICAweEYwLCAweDgwLCAweEYwLCAweDkwLCAweEYwLCAvLyA2XG4gICAgMHhGMCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg0MCwgLy8gN1xuICAgIDB4RjAsIDB4OTAsIDB4RjAsIDB4OTAsIDB4RjAsIC8vIDhcbiAgICAweEYwLCAweDkwLCAweEYwLCAweDEwLCAweEYwLCAvLyA5XG4gICAgMHhGMCwgMHg5MCwgMHhGMCwgMHg5MCwgMHg5MCwgLy8gQVxuICAgIDB4RTAsIDB4OTAsIDB4RTAsIDB4OTAsIDB4RTAsIC8vIEJcbiAgICAweEYwLCAweDgwLCAweDgwLCAweDgwLCAweEYwLCAvLyBDXG4gICAgMHhFMCwgMHg5MCwgMHg5MCwgMHg5MCwgMHhFMCwgLy8gRFxuICAgIDB4RjAsIDB4ODAsIDB4RjAsIDB4ODAsIDB4RjAsIC8vIEVcbiAgICAweEYwLCAweDgwLCAweEYwLCAweDgwLCAweDgwIC8vIEZcbiAgXVxuXG4gIG1lbW9yeS5zZXQoZm9udHMsIDApXG5cbiAgLy8gVGhlcmUgYXJlIDIgdGltZXJzLCBhIGRlbGF5IHRpbWVyIGFuZCBhIHNvdW5kIHRpbWVyLCBib3RoIGRlY3JlYXNlIHRvIDAgYXQgYSByYXRlIG9mIDYwSHosXG4gIC8vIG9uY2UgYXQgMCB0aGV5IHN0YXkgdGhlcmVcbiAgbGV0IGRlbGF5VGltZXIgPSAwXG5cbiAgLy8gV2hlbiB0aGUgc291bmQgdGltZXIgaGl0cyAwLCBhIG1vbm90b25lIHNvdW5kIGlzIHBsYXllZC5cbiAgbGV0IHNvdW5kVGltZXIgPSAwXG5cbiAgLy8gQW5kIG9mIGNvdXJzZSBhICgxNi1iaXQpIHByb2dyYW0gY291bnRlciwgc3RhcnRpbmcgYXQuLi4gMHgyMDAgKHdoZXJlIHRoZSBwcm9ncmFtIGlzIGxvYWRlZCBpbiEpXG4gIGxldCBwYyA9IDB4MjAwXG5cbiAgLy8gSXQgYWxzbyBoYXMgYSAxNi1iaXQgcmVnaXN0ZXIsIHVzdWFsbHkgdXNlZCBmb3IgYWRkcmVzc2luZyBtZW1vcnlcbiAgbGV0IGlSZWdpc3RlciA9IHBjXG5cbiAgLy8gQSBzdGFjayBwb2ludGVyLCBhbGxvd3MgdXMgdG8gaGF2ZSBmdW5jdGlvbiBjYWxscy5cbiAgbGV0IHNwID0gMFxuXG4gIC8vIFRoZSBzdGFjay4gRG9jdW1lbnRhdGlvbiBzYXlzIGl0J3MgMTYgZGVlcCwgYnV0IGFwcGFyZW50bHkgb25seSAxMCBhcmUgZXZlciB1c2VkP1xuICBsZXQgc3RhY2sgPSBuZXcgQXJyYXkoMTYpXG5cbiAgLy8gSXQgdXRpbGlzZXMgYSA2NHgzMiBwaXhlbCBkaXNwbGF5Li4uIHdlIHdpbGwgZ2V0IHRoZSBjaGlwLTggdG8gd3JpdGUgdG8gdGhlc2UgdmFsdWVzLCBhbmQgaW4gb3VyIGBlbXVsYXRvcmAgY29kZSxcbiAgLy8gd2Ugd2lsbCB3cml0ZSB0aGVzZSB2YWx1ZXMgdG8gYSBzY3JlZW4uIFNpbXBsZSEgKHNob3VsZCBiZSEpLlxuICBjb25zdCBESVNQTEFZX1dJRFRIID0gNjRcbiAgY29uc3QgRElTUExBWV9IRUlHSFQgPSAzMlxuICBsZXQgZGlzcGxheSA9IG5ldyBBcnJheShESVNQTEFZX1dJRFRIKS5maWxsKCkubWFwKF8gPT4gbmV3IEFycmF5KERJU1BMQVlfSEVJR0hUKS5maWxsKDApKVxuXG4gIGxldCBkcmF3RmxhZyA9IHRydWVcbiAgbGV0IGFuaW1hdGlvbkZyYW1lXG5cbiAgZnVuY3Rpb24gc2V0TWVtb3J5IChmaWxlLCBzdGFydCkge1xuICAgIG1lbW9yeS5zZXQoZmlsZSwgc3RhcnQpXG4gIH1cblxuICBmdW5jdGlvbiBnZXREaXNwbGF5ICgpIHtcbiAgICByZXR1cm4gZGlzcGxheVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnQgKCkge1xuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZy4uLicpXG4gICAgbGV0IGxhc3RUaW1lVXBkYXRlZCA9IERhdGUubm93KClcbiAgICBjb25zdCBjcHVTcGVlZCA9IDEwMDAgLyA1MDAgLy8gNTAwTWh6XG4gICAgYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AgKCkge1xuICAgICAgLy8gY3ljbGUgdGhlIENQVSBcIm1hbnlcIiB0aW1lcywgZGVwZW5kaW5nIG9uIGhvdyBsb25nIHRoZSBkcmF3IGxvb3AgdG9va1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgICAgY29uc3QgZGlmZiA9IG5vdyAtIGxhc3RUaW1lVXBkYXRlZFxuICAgICAgY29uc3QgY3ljbGVzID0gTWF0aC5mbG9vcihkaWZmIC8gY3B1U3BlZWQpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN5Y2xlczsgaSArPSAxKSB7XG4gICAgICAgIGN5Y2xlKClcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYXdGbGFnKSB7XG4gICAgICAgIHJlbmRlcigpXG4gICAgICAgIGRyYXdGbGFnID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgbGFzdFRpbWVVcGRhdGVkID0gbm93XG5cbiAgICAgIGFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZXNldCAoKSB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lKVxuICAgIG1lbW9yeSA9IG5ldyBVaW50OEFycmF5KDQwOTYpXG4gICAgdlJlZ2lzdGVycyA9IG5ldyBVaW50OEFycmF5KDE2KVxuICAgIG1lbW9yeS5zZXQoZm9udHMsIDApXG4gICAgZGlzcGxheSA9IG5ldyBBcnJheShESVNQTEFZX1dJRFRIKS5maWxsKCkubWFwKF8gPT4gbmV3IEFycmF5KERJU1BMQVlfSEVJR0hUKS5maWxsKDApKVxuICAgIHBjID0gMHgyMDBcbiAgICBzdGFjayA9IG5ldyBBcnJheSgxNilcbiAgICBkcmF3RmxhZyA9IHRydWVcbiAgICBkZWxheVRpbWVyID0gMFxuICAgIHNvdW5kVGltZXIgPSAwXG4gICAgaVJlZ2lzdGVyID0gcGNcbiAgfVxuXG4gIC8vIGRvZXMgYSBjcHUgY3ljbGUgaW5uaXQuXG4gIGxldCBsYXN0VGltZURlY3JlbWVudGVkID0gMFxuICBmdW5jdGlvbiBjeWNsZSAoKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgZFQgPSBjdXJyZW50VGltZSAtIGxhc3RUaW1lRGVjcmVtZW50ZWRcbiAgICBjb25zdCB0aW1lclJlZnJlc2hSYXRlID0gMTAwMCAvIDYwXG4gICAgaWYgKGRUID49IHRpbWVyUmVmcmVzaFJhdGUpIHtcbiAgICAgIC8vIGRlY3JlbWVudCBkZWxheVRpbWVyIGF0IGEgcmF0ZSBvZiA2MEh6XG4gICAgICBpZiAoZGVsYXlUaW1lciA+IDApIHtcbiAgICAgICAgZGVsYXlUaW1lciAtPSAxXG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VuZFRpbWVyID4gMCkge1xuICAgICAgICBzb3VuZFRpbWVyIC09IDFcbiAgICAgICAgaWYgKHNvdW5kVGltZXIgPT09IDApIHtcbiAgICAgICAgICBzb3VuZC5wbGF5KClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0VGltZURlY3JlbWVudGVkID0gY3VycmVudFRpbWVcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0ID0gZmV0Y2goKVxuXG4gICAgLy8gZGVjb2RlICYgZXhlY3V0ZSAoaSdtIHRvbyBsYXp5IHRvIGhhdmUgdGhlbSBkbyBzZXBhcmF0ZWx5LCBmZWVscyBsaWtlIGEgd2FzdGU/IFdlJ2xsIHNlZS4uLilcbiAgICBkZWNvZGVBbmRFeGVjdXRlKGluc3QpXG4gIH1cblxuICAvLyBmZXRjaGluZyBmcm9tIG1lbW9yeSB0YWtlcyB0d29vb28gY3ljbGVzLCBjb3MgaXQncyBhbiA4LWJpdCBidXMsXG4gIC8vIGJ1dCBlYWNoIGluc3RydWN0aW9uIGlzIDE2LWJpdHMgbG9uZy5cbiAgZnVuY3Rpb24gZmV0Y2ggKCkge1xuICAgIGNvbnN0IGluc3QgPSAobWVtb3J5W3BjXSA8PCA4KSB8IG1lbW9yeVtwYyArIDFdXG4gICAgcGMgKz0gMlxuXG4gICAgcmV0dXJuIGluc3RcbiAgfVxuXG4gIC8vIGFpZ2h0IHdlIGdvdCBhIGhleCB2YWx1ZSBub3cgd2UgbmVlZCB0byBsb29rIHVwIHdoYXQgdGhhdCBtZWFucyBleGFjdGx5XG4gIGZ1bmN0aW9uIGRlY29kZUFuZEV4ZWN1dGUgKGluc3QpIHtcbiAgICAvLyBNYW55IG9mIHRoZSBpbnN0cnVjdGlvbnMgZm9sbG93IHRoZSBzdHJ1Y3R1cmUgYmVsb3csIHNvIHRvIG1ha2UgbXkgbGlmZSBzaW1wbGVyLCBJIHdpbGwgY2FsY3VsYXRlIHRoZXNlIHZhbHVlc1xuICAgIC8vIGZyb20gdGhlIGluc3RydWN0aW9uIFdlIGFyZSB1c2luZyBiaXRtYXNraW5nIHRvIGdldCB0aGVzZSB2YWx1ZXMuIElmIHlvdSBkb24ndCBxdWl0ZSBnZXQgd2hhdCdzIGhhcHBlbmluZyBoZXJlLFxuICAgIC8vIGxvb2sgdXAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFza18oY29tcHV0aW5nKVxuXG4gICAgY29uc3Qgbm5uID0gaW5zdCAmIDB4MEZGRiAvLyBubm4gb3IgYWRkciAtIEEgMTItYml0IHZhbHVlLCB0aGUgbG93ZXN0IDEyIGJpdHMgb2YgdGhlIGluc3RydWN0aW9uXG4gICAgY29uc3QgbiA9IGluc3QgJiAweDAwMEYgLy8gbiBvciBuaWJibGUgLSBBIDQtYml0IHZhbHVlLCB0aGUgbG93ZXN0IDQgYml0cyBvZiB0aGUgaW5zdHJ1Y3Rpb25cbiAgICBjb25zdCB4ID0gKGluc3QgJiAweDBGMDApID4+IDggLy8geCAtIEEgNC1iaXQgdmFsdWUsIHRoZSBsb3dlciA0IGJpdHMgb2YgdGhlIGhpZ2ggYnl0ZSBvZiB0aGUgaW5zdHJ1Y3Rpb25jdGlvblxuICAgIGNvbnN0IHkgPSAoaW5zdCAmIDB4MDBGMCkgPj4gNC8vIHkgLSBBIDQtYml0IHZhbHVlLCB0aGUgdXBwZXIgNCBiaXRzIG9mIHRoZSBsb3cgYnl0ZSBvZiB0aGUgaW5zdHJ1XG4gICAgY29uc3Qga2sgPSBpbnN0ICYgMHgwMEZGIC8vIGtrIG9yIGJ5dGUgLSBBbiA4LWJpdCB2YWx1ZSwgdGhlIGxvd2VzdCA4IGJpdHMgb2YgdGhlIGluc3RydWN0aW9uXG5cbiAgICAvLyBnb25uYSBzcGxpdCB0aGlzIGludG8gJ21hY3JvIGxldmVsIG9wY29kZXMnIGFuZCAnbWljcm8gbGV2ZWwgb3Bjb2RlcycsIGFzIHRoZSBpbnN0cnVjdGlvbnMgY2FuIGJlIGluZGV4ZWQgYnkgdGhlXG4gICAgLy8gaGlnaGVzdCBieXRlIGZpcnN0LCBhbmQgdGhlbiBhZnRlciB0aGF0IHdlIGNhbiBkZWNpZGUgd2hhdCB0byBkby4uLlxuICAgIGNvbnN0IGhpZ2hCeXRlID0gaW5zdCAmIDB4RjAwMFxuICAgIC8vIFdlLi4uIGNvdWxkIHVzZSBhIHN3aXRjaCBzdGF0ZW1lbnQgaGVyZSwgYnV0IHRoYXQgd291bGQgYmUgaW5zYW5lLCByaWdodD8gSG93IGFib3V0IGEgbWFwIGluc3RlYWQ/XG4gICAgY29uc3QgbWFjcm9PcGNvZGVzID0ge1xuICAgICAgMHgwMDAwOiBjbGVhckFuZFJldHVybk9wY29kZXMsXG4gICAgICAweDEwMDA6IGp1bXAsXG4gICAgICAweDIwMDA6IGNhbGxTdWJyb3V0aW5lLFxuICAgICAgMHgzMDAwOiBza2lwSWZWeGtrLFxuICAgICAgMHg0MDAwOiBza2lwSWZOb3RWeGtrLFxuICAgICAgMHg1MDAwOiBza2lwSWZWeFZ5LFxuICAgICAgMHg2MDAwOiBsb2FkVnhWYWwsXG4gICAgICAweDcwMDA6IGFkZFZ4VmFsLFxuICAgICAgMHg4MDAwOiBzZXR0aW5nRnVuY3MsXG4gICAgICAweDkwMDA6IHNraXBJZk5vdFZ4VnksXG4gICAgICAweEEwMDA6IGxvYWRJQWRkcixcbiAgICAgIDB4QjAwMDoganVtcFYwT2Zmc2V0LFxuICAgICAgMHhDMDAwOiBzZXRWeFJhbmRvbSxcbiAgICAgIDB4RDAwMDogZHJhdyxcbiAgICAgIDB4RTAwMDogc2tpcEtleSxcbiAgICAgIDB4RjAwMDogcmVnaXN0ZXJNYW5pcHVsYXRpb25cbiAgICB9XG5cbiAgICBjb25zdCBtYWNyb09wY29kZSA9IG1hY3JvT3Bjb2Rlc1toaWdoQnl0ZV1cblxuICAgIG1hY3JvT3Bjb2RlKHsgbm5uLCBuLCB4LCB5LCBrayB9KSAvLyBZZXMsIHZlcnkgaW5lZmZlY2llbnQgcmlnaHQgbm93XG4gIH1cblxuICAvLyAweDAwMDBcbiAgZnVuY3Rpb24gY2xlYXJBbmRSZXR1cm5PcGNvZGVzIChpbnN0KSB7XG4gICAgLy8gaXMgdGhlIGxhc3QgYml0IHNldD8gaWYgaXQgaXMsIGl0J3MgdGhlICdSRVQnIGZ1bmN0aW9uLCBvdGhlcndpc2UgaXQncyB0aGUgJ0NMUycgZnVuY3Rpb25cbiAgICBpZiAoaW5zdC5ubm4gJiAweDAwRikge1xuICAgICAgcmV0dXJuRnJvbVN1YigpIC8vIDB4MDBFRVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclNjcmVlbigpIC8vIDB4MDBFMFxuICAgIH1cblxuICAgIC8vIDAwRTAgLSBDTFMgLT4gQ2xlYXIgdGhlIHNjcmVlblxuICAgIGZ1bmN0aW9uIGNsZWFyU2NyZWVuICgpIHtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZGlzcGxheS5sZW5ndGg7IHggKz0gMSkge1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGRpc3BsYXlbeF0ubGVuZ3RoOyB5ICs9IDEpIHtcbiAgICAgICAgICBkaXNwbGF5W3hdW3ldID0gMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMDBFRSAtIFJFVFxuICAgIC8vIFRoZSBpbnRlcnByZXRlciBzZXRzIHRoZSBwcm9ncmFtIGNvdW50ZXIgdG8gdGhlIGFkZHJlc3MgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2ssIHRoZW4gc3VidHJhY3RzIDEgZnJvbSB0aGUgc3RhY2tcbiAgICAvLyBwb2ludGVyLiBXZSdyZSBkb2luZyBpdCB0aGUgb3RoZXIgd2F5IGFyb3VuZCAoc3VidHJhY3QsIFRIRU4gc2V0KSwgYmVjYXVzZSBvdGhlcndpc2Ugb3VyICdzdGFjaydzJyAod2hpY2ggaXMgYW5cbiAgICAvLyBhcnJheSkgZmlyc3QgZWxlbWVudCBpcyBuZXZlciBzZXQgKHN0YWNrWzBdIHdpbGwgbmV2ZXIgYmUgdXNlZClcbiAgICBmdW5jdGlvbiByZXR1cm5Gcm9tU3ViICgpIHtcbiAgICAgIHNwIC09IDFcbiAgICAgIHBjID0gc3RhY2tbc3BdXG4gICAgfVxuICB9XG5cbiAgLy8gMW5ubiAtIEpQIGFkZHIgLT4gU2V0cyBwYyB0byBubm5cbiAgZnVuY3Rpb24ganVtcCAoaW5zdCkge1xuICAgIHBjID0gaW5zdC5ubm5cbiAgfVxuXG4gIC8vIDJubm4gLSBDQUxMIGFkZHJcbiAgLy8gQ2FsbCBzdWJyb3V0aW5lIGF0IG5ubi5cbiAgLy8gVGhlIGludGVycHJldGVyIGluY3JlbWVudHMgdGhlIHN0YWNrIHBvaW50ZXIsIHRoZW4gcHV0cyB0aGUgY3VycmVudCBQQyBvbiB0aGUgdG9wIG9mIHRoZSBzdGFjay4gVGhlIFBDIGlzIHRoZW4gc2V0XG4gIC8vIHRvIG5ubi4gV2UncmUgZG9pbmcgdGhpcyB0aGUgb3RoZXIgd2F5IGFyb3VuZCAoc2V0LCB0aGVuIGluY3JlbWVudCksIHNlZSAwMEVFIGZvciBtb3JlIGluZm8uXG4gIGZ1bmN0aW9uIGNhbGxTdWJyb3V0aW5lIChpbnN0KSB7XG4gICAgc3RhY2tbc3BdID0gcGNcbiAgICBzcCArPSAxXG4gICAgcGMgPSBpbnN0Lm5ublxuICB9XG5cbiAgLy8gM3hrayAtIFNFIFZ4LCBieXRlIC0+IFRoZSBpbnRlcnByZXRlciBjb21wYXJlcyByZWdpc3RlciBWeCB0byBraywgYW5kIGlmIHRoZXkgYXJlIGVxdWFsLCBpbmNyZW1lbnRzIHBjIGJ5IDIuXG4gIGZ1bmN0aW9uIHNraXBJZlZ4a2sgKGluc3QpIHsgLy8gNXh5MCAtIFNFIFZ4LCBWeVxuICAgIGlmICh2UmVnaXN0ZXJzW2luc3QueF0gPT09IGluc3Qua2spIHtcbiAgICAgIHBjICs9IDJcbiAgICB9XG4gIH1cblxuICAvLyA0eGtrIC0gU05FIFZ4LCBieXRlXG4gIC8vIFNraXAgbmV4dCBpbnN0cnVjdGlvbiBpZiBWeCAhPSBray5cbiAgLy8gVGhlIGludGVycHJldGVyIGNvbXBhcmVzIHJlZ2lzdGVyIFZ4IHRvIGtrLCBhbmQgaWYgdGhleSBhcmUgbm90IGVxdWFsLCBpbmNyZW1lbnRzIHRoZSBwcm9ncmFtIGNvdW50ZXIgYnkgMi5cbiAgZnVuY3Rpb24gc2tpcElmTm90VnhrayAoaW5zdCkge1xuICAgIGlmICh2UmVnaXN0ZXJzW2luc3QueF0gIT09IGluc3Qua2spIHtcbiAgICAgIHBjICs9IDJcbiAgICB9XG4gIH1cblxuICAvLyA1eHkwIC0gU0UgVngsIFZ5XG4gIC8vIFNraXAgbmV4dCBpbnN0cnVjdGlvbiBpZiBWeCA9IFZ5LlxuICAvLyBUaGUgaW50ZXJwcmV0ZXIgY29tcGFyZXMgcmVnaXN0ZXIgVnggdG8gcmVnaXN0ZXIgVnksIGFuZCBpZiB0aGV5IGFyZSBlcXVhbCwgaW5jcmVtZW50cyB0aGUgcHJvZ3JhbSBjb3VudGVyIGJ5IDIuXG4gIGZ1bmN0aW9uIHNraXBJZlZ4VnkgKGluc3QpIHtcbiAgICBpZiAodlJlZ2lzdGVyc1tpbnN0LnhdID09PSB2UmVnaXN0ZXJzW2luc3QueV0pIHtcbiAgICAgIHBjICs9IDJcbiAgICB9XG4gIH1cblxuICAvLyA2eGtrIC0gTEQgVngsIGJ5dGVcbiAgLy8gU2V0IFZ4ID0ga2suXG4gIC8vIFRoZSBpbnRlcnByZXRlciBwdXRzIHRoZSB2YWx1ZSBrayBpbnRvIHJlZ2lzdGVyIFZ4LlxuICBmdW5jdGlvbiBsb2FkVnhWYWwgKGluc3QpIHtcbiAgICB2UmVnaXN0ZXJzW2luc3QueF0gPSBpbnN0LmtrXG4gIH1cblxuICAvLyAweDcwMDBcbiAgLy8gU2V0IFZ4ID0gVnggKyBray5cbiAgLy8gQWRkcyB0aGUgdmFsdWUga2sgdG8gdGhlIHZhbHVlIG9mIHJlZ2lzdGVyIFZ4LCB0aGVuIHN0b3JlcyB0aGUgcmVzdWx0IGluIFZ4LlxuICBmdW5jdGlvbiBhZGRWeFZhbCAoaW5zdCkge1xuICAgIHZSZWdpc3RlcnNbaW5zdC54XSA9IHZSZWdpc3RlcnNbaW5zdC54XSArIGluc3Qua2tcbiAgfVxuXG4gIC8vIDB4ODAwMFxuICBmdW5jdGlvbiBzZXR0aW5nRnVuY3MgKGluc3QpIHtcbiAgICBjb25zdCBtaWNyb09wQ29kZXMgPSB7XG4gICAgICAweDA6IGxvYWRWeFZ5LFxuICAgICAgMHgxOiB2WE9yVnksXG4gICAgICAweDM6IFZ4WG9yVnksXG4gICAgICAweDI6IHZYQW5kVnksXG4gICAgICAweDQ6IHZYQWRkVnksXG4gICAgICAweDU6IHZYU3ViVnksXG4gICAgICAweDY6IHNoaWZ0UmlnaHQsXG4gICAgICAweDc6IHZZU3ViVngsXG4gICAgICAweEU6IHNoaWZ0TGVmdFxuICAgIH1cblxuICAgIC8vIDh4eTAgLSBMRCBWeCwgVnkgLT4gVnggPSBWeVxuICAgIGZ1bmN0aW9uIGxvYWRWeFZ5ICgpIHtcbiAgICAgIHZSZWdpc3RlcnNbaW5zdC54XSA9IHZSZWdpc3RlcnNbaW5zdC55XVxuICAgIH1cblxuICAgIC8vIDh4eTEgLSBPUiBWeCwgVnkgLT4gVnggPSBWeCB8IFZ5XG4gICAgZnVuY3Rpb24gdlhPclZ5ICgpIHtcbiAgICAgIHZSZWdpc3RlcnNbaW5zdC54XSA9IHZSZWdpc3RlcnNbaW5zdC54XSB8IHZSZWdpc3RlcnNbaW5zdC55XVxuICAgIH1cblxuICAgIC8vIDh4eTIgLSBBTkQgVngsIFZ5IC0+IFZ4ID0gVnggJiBWeVxuICAgIGZ1bmN0aW9uIHZYQW5kVnkgKCkge1xuICAgICAgdlJlZ2lzdGVyc1tpbnN0LnhdID0gdlJlZ2lzdGVyc1tpbnN0LnhdICYgdlJlZ2lzdGVyc1tpbnN0LnldXG4gICAgfVxuXG4gICAgLy8gOHh5MyAtIFhPUiBWeCwgVnkgLT4gU2V0IFZ4ID0gVnggWE9SIFZ5LlxuICAgIGZ1bmN0aW9uIFZ4WG9yVnkgKCkge1xuICAgICAgdlJlZ2lzdGVyc1tpbnN0LnhdID0gdlJlZ2lzdGVyc1tpbnN0LnhdIF4gdlJlZ2lzdGVyc1tpbnN0LnldXG4gICAgfVxuXG4gICAgLy8gOHh5NCAtIEFERCBWeCwgVnkgLT4gVnggPSBWeCArIFZ5IC0+IFZ4ID0gVnggKyBWeSwgc2V0IFZGID0gY2FycnkuXG4gICAgZnVuY3Rpb24gdlhBZGRWeSAoKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB2UmVnaXN0ZXJzW2luc3QueF0gKyB2UmVnaXN0ZXJzW2luc3QueV1cblxuICAgICAgaWYgKHJlc3VsdCA+IDB4RkYpIHtcbiAgICAgICAgdlJlZ2lzdGVyc1sweEZdID0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdlJlZ2lzdGVyc1sweEZdID0gMFxuICAgICAgfVxuXG4gICAgICB2UmVnaXN0ZXJzW2luc3QueF0gPSByZXN1bHQgJiAweEZGXG4gICAgfVxuXG4gICAgLy8gOHh5NSAtIFNVQiBWeCwgVnlcbiAgICAvLyBTZXQgVnggPSBWeCAtIFZ5LCBzZXQgVkYgPSBOT1QgYm9ycm93LlxuICAgIC8vIElmIFZ4ID4gVnksIHRoZW4gVkYgaXMgc2V0IHRvIDEsIG90aGVyd2lzZSAwLiBUaGVuIFZ5IGlzIHN1YnRyYWN0ZWQgZnJvbSBWeCwgYW5kIHRoZSByZXN1bHRzIHN0b3JlZCBpbiBWeC5cbiAgICBmdW5jdGlvbiB2WFN1YlZ5ICgpIHtcbiAgICAgIGlmICh2UmVnaXN0ZXJzW2luc3QueF0gPiB2UmVnaXN0ZXJzW2luc3QueV0pIHtcbiAgICAgICAgdlJlZ2lzdGVyc1sweEZdID0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdlJlZ2lzdGVyc1sweEZdID0gMFxuICAgICAgfVxuXG4gICAgICB2UmVnaXN0ZXJzW2luc3QueF0gPSAodlJlZ2lzdGVyc1tpbnN0LnhdIC0gdlJlZ2lzdGVyc1tpbnN0LnldKSAmIDB4RkZcbiAgICB9XG5cbiAgICAvLyA4eHk2IC0gU0hSIFZ4IHssIFZ5fSAtPiBWWzB4Rl0gPSBWeCAmIDB4MS4gU2V0IFZ4ID0gVnggPj4gMVxuICAgIGZ1bmN0aW9uIHNoaWZ0UmlnaHQgKCkge1xuICAgICAgdlJlZ2lzdGVyc1sweEZdID0gdlJlZ2lzdGVyc1tpbnN0LnhdICYgMGIxXG4gICAgICB2UmVnaXN0ZXJzW2luc3QueF0gPSB2UmVnaXN0ZXJzW2luc3QueF0gPj4gMVxuICAgIH1cblxuICAgIC8vIDh4eTcgLSBTVUJOIFZ4LCBWeSAtPiBTZXQgVnggPSBWeSAtIFZ4LCBzZXQgVkYgPSBOT1QgYm9ycm93LlxuICAgIGZ1bmN0aW9uIHZZU3ViVnggKCkge1xuICAgICAgaWYgKHZSZWdpc3RlcnNbaW5zdC55XSA+IHZSZWdpc3RlcnNbaW5zdC54XSkge1xuICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAwXG4gICAgICB9XG5cbiAgICAgIHZSZWdpc3RlcnNbaW5zdC54XSA9IHZSZWdpc3RlcnNbaW5zdC55XSAtIHZSZWdpc3RlcnNbaW5zdC54XVxuICAgIH1cblxuICAgIC8vIDh4eUUgLSBTSEwgVnggeywgVnl9IC0+IFZbMHhGXSA9IDEgaWYgVnggPj0gMHg4MCwgZWxzZSAwLiBUaGVuIFZ4ID0gVnggPDwgMS5cbiAgICBmdW5jdGlvbiBzaGlmdExlZnQgKCkge1xuICAgICAgaWYgKHZSZWdpc3RlcnNbaW5zdC54XSAmIDBiMTAwMDAwMDApIHtcbiAgICAgICAgdlJlZ2lzdGVyc1sweEZdID0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdlJlZ2lzdGVyc1sweEZdID0gMFxuICAgICAgfVxuXG4gICAgICB2UmVnaXN0ZXJzW2luc3QueF0gPSB2UmVnaXN0ZXJzW2luc3QueF0gPDwgMVxuICAgIH1cblxuICAgIGlmICghbWljcm9PcENvZGVzW2luc3Qubl0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYE1pc3NpbmcgaW5zdHJ1Y3Rpb246ICR7aW5zdC5uLnRvU3RyaW5nKDE2KX1gKVxuICAgIH1cblxuICAgIG1pY3JvT3BDb2Rlc1tpbnN0Lm5dKClcbiAgfVxuXG4gIC8vIDl4eTAgLSBTTkUgVngsIFZ5IC0+IFNraXAgbmV4dCBpbnN0cnVjdGlvbiBpZiBWeCAhPSBWeS5cbiAgZnVuY3Rpb24gc2tpcElmTm90VnhWeSAoaW5zdCkge1xuICAgIGlmICh2UmVnaXN0ZXJzW2luc3QueF0gIT09IHZSZWdpc3RlcnNbaW5zdC55XSkge1xuICAgICAgcGMgKz0gMlxuICAgIH1cbiAgfVxuXG4gIC8vIDB4QTAwMCAtPiBpID0gbm5uXG4gIGZ1bmN0aW9uIGxvYWRJQWRkciAoaW5zdCkge1xuICAgIGlSZWdpc3RlciA9IGluc3Qubm5uXG4gIH1cblxuICAvLyBCbm5uIC0gSlAgVjAsIGFkZHIgLT4gcGMgPSBubm4gKyBWMC5cbiAgZnVuY3Rpb24ganVtcFYwT2Zmc2V0IChpbnN0KSB7XG4gICAgcGMgPSBpbnN0Lm5ubiArIHZSZWdpc3RlcnNbMF1cbiAgfVxuXG4gIC8vIEN4a2sgLSBSTkQgVngsIGJ5dGUgLT4gU2V0IFZ4ID0gcmFuZG9tIGJ5dGUgQU5EIGtrLlxuICBmdW5jdGlvbiBzZXRWeFJhbmRvbSAoaW5zdCkge1xuICAgIGNvbnN0IHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oMSkgKiAyNTUpXG4gICAgdlJlZ2lzdGVyc1tpbnN0LnhdID0gcmFuZG9tICYgaW5zdC5ra1xuICB9XG5cbiAgLy8gRHh5biAtIERSVyBWeCwgVnksIG5pYmJsZVxuICAvLyBEaXNwbGF5IG4tYnl0ZSBzcHJpdGUgc3RhcnRpbmcgYXQgbWVtb3J5IGxvY2F0aW9uIEkgYXQgKFZ4LCBWeSksIHNldCBWRiA9IGNvbGxpc2lvbi5cbiAgLy8gVGhlIGludGVycHJldGVyIHJlYWRzIG4gYnl0ZXMgZnJvbSBtZW1vcnksIHN0YXJ0aW5nIGF0IHRoZSBhZGRyZXNzIHN0b3JlZCBpbiBJLlxuICAvLyBUaGVzZSBieXRlcyBhcmUgdGhlbiBkaXNwbGF5ZWQgYXMgc3ByaXRlcyBvbiBzY3JlZW4gYXQgY29vcmRpbmF0ZXMgKFZ4LCBWeSkuXG4gIC8vIFNwcml0ZXMgYXJlIFhPUmVkIG9udG8gdGhlIGV4aXN0aW5nIHNjcmVlbi5cbiAgLy8gSWYgdGhpcyBjYXVzZXMgYW55IHBpeGVscyB0byBiZSBlcmFzZWQsIFZGIGlzIHNldCB0byAxLCBvdGhlcndpc2UgaXQgaXMgc2V0IHRvIDAuXG4gIC8vIElmIHRoZSBzcHJpdGUgaXMgcG9zaXRpb25lZCBzbyBwYXJ0IG9mIGl0IGlzIG91dHNpZGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBkaXNwbGF5LCBpIHQgd3JhcHMgYXJvdW5kIHRvIHRoZVxuICAvLyBvcHBvc2l0ZSBzaWRlIG9mIHRoZSBzY3JlZW4uXG4gIGZ1bmN0aW9uIGRyYXcgKGluc3QpIHtcbiAgICBsZXQgeCA9IHZSZWdpc3RlcnNbaW5zdC54XVxuICAgIGxldCB5ID0gdlJlZ2lzdGVyc1tpbnN0LnldXG4gICAgbGV0IGlBZGRyID0gaVJlZ2lzdGVyXG4gICAgdlJlZ2lzdGVyc1sweEZdID0gMFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0Lm47IGkgKz0gMSkge1xuICAgICAgY29uc3QgbmV3WSA9ICh5ICsgaSkgJSBESVNQTEFZX0hFSUdIVFxuXG4gICAgICBjb25zdCBsaW5lID0gbWVtb3J5W2lBZGRyXVxuICAgICAgaUFkZHIgKz0gMVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IFdPUkRfU0laRTsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IG5ld1ggPSAoeCArIGopICUgRElTUExBWV9XSURUSFxuXG4gICAgICAgIGNvbnN0IGJpdG1hc2sgPSAwYjAwMDAwMDAxIDw8IChXT1JEX1NJWkUgLSAxIC0gailcbiAgICAgICAgY29uc3QgcGl4ZWwgPSAobGluZSAmIGJpdG1hc2spID4+IChXT1JEX1NJWkUgLSAxIC0gailcblxuICAgICAgICBjb25zdCBjdXJyZW50UGl4ZWwgPSBkaXNwbGF5W25ld1hdW25ld1ldXG4gICAgICAgIGNvbnN0IG5ld1BpeGVsID0gY3VycmVudFBpeGVsIF4gcGl4ZWxcblxuICAgICAgICBkaXNwbGF5W25ld1hdW25ld1ldID0gbmV3UGl4ZWxcblxuICAgICAgICBpZiAoY3VycmVudFBpeGVsID4gbmV3UGl4ZWwpIHtcbiAgICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkcmF3RmxhZyA9IHRydWVcbiAgfVxuXG4gIC8vIDB4RTAwMFxuICBmdW5jdGlvbiBza2lwS2V5IChpbnN0KSB7XG4gICAgLy8gRXg5RSAtIFNLUCBWeCAtPiBTa2lwIG5leHQgaW5zdHJ1Y3Rpb24gaWYga2V5IHdpdGggdGhlIHZhbHVlIG9mIFZ4IGlzIHByZXNzZWQuXG4gICAgaWYgKGluc3Qua2sgPT09IDB4OUUpIHtcbiAgICAgIGNvbnN0IGlzS2V5UHJlc3NlZCA9IGtleWJvYXJkLmdldCh2UmVnaXN0ZXJzW2luc3QueF0pXG4gICAgICBpZiAoaXNLZXlQcmVzc2VkKSB7XG4gICAgICAgIHBjICs9IDJcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEV4QTEgLSBTS05QIFZ4XG4gICAgLy8gU2tpcCBuZXh0IGluc3RydWN0aW9uIGlmIGtleSB3aXRoIHRoZSB2YWx1ZSBvZiBWeCBpcyBub3QgcHJlc3NlZC5cbiAgICAvLyBDaGVja3MgdGhlIGtleWJvYXJkLCBhbmQgaWYgdGhlIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSB2YWx1ZSBvZiBWeCBpcyBjdXJyZW50bHkgaW4gdGhlIHVwIHBvc2l0aW9uLCBQQyBpc1xuICAgIC8vIGluY3JlYXNlZCBieSAyLlxuICAgIGlmIChpbnN0LmtrID09PSAweEExKSB7XG4gICAgICBjb25zdCBpc0tleVByZXNzZWQgPSBrZXlib2FyZC5nZXQodlJlZ2lzdGVyc1tpbnN0LnhdKVxuICAgICAgaWYgKCFpc0tleVByZXNzZWQpIHtcbiAgICAgICAgcGMgKz0gMlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIDB4RjAwMFxuICBmdW5jdGlvbiByZWdpc3Rlck1hbmlwdWxhdGlvbiAoaW5zdCkge1xuICAgIGNvbnN0IG1pY3JvT3BDb2RlcyA9IHtcbiAgICAgIDB4MDc6IGxvYWREZWxheVRpbWVyLFxuICAgICAgMHgwQTogd2FpdEZvcktleVByZXNzLFxuICAgICAgMHgxNTogc2V0RGVsYXlUaW1lcixcbiAgICAgIDB4MTg6IHNldFNvdW5kVGltZXIsXG4gICAgICAweDFFOiBhZGRJVngsXG4gICAgICAweDI5OiBsb2FkSVZ4LFxuICAgICAgMHgzMzogc3RvcmVCY2QsXG4gICAgICAweDU1OiBsb2FkSVYwVG9WeCxcbiAgICAgIDB4NjU6IGxvYWRWMFRvVnhJXG4gICAgfVxuXG4gICAgLy8gRngwNyAtIExEIFZ4LCBEVCAtPiBUaGUgdmFsdWUgb2YgRFQgaXMgcGxhY2VkIGludG8gVnguXG4gICAgZnVuY3Rpb24gbG9hZERlbGF5VGltZXIgKCkge1xuICAgICAgdlJlZ2lzdGVyc1tpbnN0LnhdID0gZGVsYXlUaW1lclxuICAgIH1cblxuICAgIC8vIEZ4MTUgLSBMRCBEVCwgVnggLT4gRFQgaXMgc2V0IGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBWeC5cbiAgICBmdW5jdGlvbiBzZXREZWxheVRpbWVyICgpIHtcbiAgICAgIGRlbGF5VGltZXIgPSB2UmVnaXN0ZXJzW2luc3QueF1cbiAgICB9XG5cbiAgICAvLyBGeDFFIC0gQUREIEksIFZ4IC0+IFNldCBJID0gSSArIFZ4LlxuICAgIGZ1bmN0aW9uIGFkZElWeCAoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGlSZWdpc3RlciArIHZSZWdpc3RlcnNbaW5zdC54XVxuXG4gICAgICBpZiAodmFsdWUgPiAweEZGRikge1xuICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAwXG4gICAgICB9XG5cbiAgICAgIGlSZWdpc3RlciA9IHZhbHVlICYgMHhGRkZcbiAgICB9XG5cbiAgICAvLyBGeDI5IC0gTEQgRiwgVnggLT4gU2V0IEkgPSBsb2NhdGlvbiBvZiBzcHJpdGUgZm9yIGRpZ2l0IFZ4LlxuICAgIGZ1bmN0aW9uIGxvYWRJVnggKCkge1xuICAgICAgaVJlZ2lzdGVyID0gdlJlZ2lzdGVyc1tpbnN0LnhdICogNVxuICAgIH1cblxuICAgIC8vIEZ4MzMgLSBMRCBCLCBWeFxuICAgIC8vIFN0b3JlIEJDRCByZXByZXNlbnRhdGlvbiBvZiBWeCBpbiBtZW1vcnkgbG9jYXRpb25zIEksIEkrMSwgYW5kIEkrMi5cbiAgICAvLyBUaGUgaW50ZXJwcmV0ZXIgdGFrZXMgdGhlIGRlY2ltYWwgdmFsdWUgb2YgVngsIGFuZCBwbGFjZXMgdGhlIGh1bmRyZWRzIGRpZ2l0IGluXG4gICAgLy8gbWVtb3J5IGF0IGxvY2F0aW9uIGluIEksIHRoZSB0ZW5zIGRpZ2l0IGF0IGxvY2F0aW9uIEkrMSwgYW5kIHRoZSBvbmVzIGRpZ2l0IGF0IGxvY2F0aW9uIEkrMi5cbiAgICBmdW5jdGlvbiBzdG9yZUJjZCAoKSB7XG4gICAgICBjb25zdCBkZWMgPSB2UmVnaXN0ZXJzW2luc3QueF1cblxuICAgICAgLy8gRm9yIGEgZ2l2ZW4gdmFsdWUsIHNheSAyMzRcbiAgICAgIG1lbW9yeVtpUmVnaXN0ZXJdID0gTWF0aC5mbG9vcihkZWMgLyAxMDApIC8vIEdpdmVzIHVzIDJcbiAgICAgIG1lbW9yeVtpUmVnaXN0ZXIgKyAxXSA9IE1hdGguZmxvb3IoZGVjIC8gMTApICUgMTAgLy8gR2l2ZXMgdXMgM1xuICAgICAgbWVtb3J5W2lSZWdpc3RlciArIDJdID0gZGVjICUgMTAgLy8gR2l2ZXMgdXMgNFxuICAgIH1cblxuICAgIC8vIEZ4NTUgLSBMRCBbSV0sIFZ4IC0+IFZbMF0uLi5WW3hdID0+IG1lbW9yeVtJXS4uLm1lbW9yeVtJICsgeF1cbiAgICBmdW5jdGlvbiBsb2FkSVYwVG9WeCAoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpbnN0Lng7IGkgKz0gMSkge1xuICAgICAgICBtZW1vcnlbaVJlZ2lzdGVyICsgaV0gPSB2UmVnaXN0ZXJzW2ldXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRng2NSAtIExEIFZ4LCBbSV0gLT4gVGhlIGludGVycHJldGVyIHJlYWRzIHZhbHVlcyBmcm9tIG1lbW9yeSBzdGFydGluZyBhdCBsb2NhdGlvbiBJIGludG8gcmVnaXN0ZXJzIFYwIHRocm91Z2ggVnguXG4gICAgZnVuY3Rpb24gbG9hZFYwVG9WeEkgKCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaW5zdC54OyBpICs9IDEpIHtcbiAgICAgICAgdlJlZ2lzdGVyc1tpXSA9IG1lbW9yeVtpUmVnaXN0ZXIgKyBpXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZ4MEEgLSBMRCBWeCwgS1xuICAgIC8vIFdhaXQgZm9yIGEga2V5IHByZXNzLCBzdG9yZSB0aGUgdmFsdWUgb2YgdGhlIGtleSBpbiBWeC5cbiAgICAvLyBBbGwgZXhlY3V0aW9uIHN0b3BzIHVudGlsIGEga2V5IGlzIHByZXNzZWQsIHRoZW4gdGhlIHZhbHVlIG9mIHRoYXQga2V5IGlzIHN0b3JlZCBpbiBWeC5cbiAgICBmdW5jdGlvbiB3YWl0Rm9yS2V5UHJlc3MgKCkge1xuICAgICAgY29uc3Qga2V5UHJlc3NlZCA9IGtleWJvYXJkLmdldEFueSgpXG5cbiAgICAgIGlmICgha2V5UHJlc3NlZCkge1xuICAgICAgICBwYyAtPSAyIC8vIGtlZXAgbG9vcGluZyB1bnRpbCBhIGtleSBpcyBwcmVzc2VkXG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZSZWdpc3RlcnNbaW5zdC54XSA9IGtleVByZXNzZWRcblxuICAgICAgcmV0dXJuIGtleVByZXNzZWRcbiAgICB9XG5cbiAgICAvLyBGeDE4IC0gTEQgU1QsIFZ4IC0+IFNldCBzb3VuZCB0aW1lciA9IFZ4LlxuICAgIGZ1bmN0aW9uIHNldFNvdW5kVGltZXIgKCkge1xuICAgICAgc291bmRUaW1lciA9IHZSZWdpc3RlcnNbaW5zdC54XVxuICAgIH1cblxuICAgIHJldHVybiBtaWNyb09wQ29kZXNbaW5zdC5ra10oKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXREaXNwbGF5LFxuICAgIHNldE1lbW9yeSxcbiAgICBzdGFydCxcbiAgICByZXNldFxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/chip-8.js\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _chip_8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chip-8 */ \"./src/chip-8.js\");\n\n\nconst SCALE = 10\n\nfunction loadMemory (file) {\n  console.log('loading memory')\n  const array = new Uint8Array(file)\n\n  chip8.setMemory(array, 0x200)\n\n  chip8.start()\n}\n\nconst canvas = document.createElement('canvas')\ncanvas.id = 'canvas'\ncanvas.width = 64 * SCALE\ncanvas.height = 32 * SCALE\ndocument.body.appendChild(canvas)\nconst context = canvas.getContext('2d')\n\nfunction render () {\n  const display = chip8.getDisplay()\n\n  for (var x = 0; x < display.length; x += 1) {\n    for (var y = 0; y < display[0].length; y += 1) {\n      const pixel = display[x][y]\n      context.fillStyle = pixel ? '#fff' : '#000'\n      context.fillRect(x * SCALE, y * SCALE, SCALE, SCALE)\n    }\n  }\n}\n\nfunction readSingleFile (event) {\n  const canvas = document.getElementById('canvas')\n  const context = canvas.getContext('2d')\n  context.fillRect(0, 0, 640, 320, '#000')\n\n  var filename = event.target.files[0]\n\n  if (!filename) return\n\n  const reader = new FileReader()\n  reader.onload = file => loadMemory(file.target.result)\n  reader.readAsArrayBuffer(filename)\n}\n\nlet keyboard = (function () {\n  const keyMap = {\n    '1': '1',\n    '2': '2',\n    '3': '3',\n    '4': 'q',\n    '5': 'w',\n    '6': 'e',\n    '7': 'a',\n    '8': 's',\n    '9': 'd',\n    'a': 'z',\n    '0': 'x',\n    'b': 'c',\n    'c': '4',\n    'd': 'r',\n    'e': 'f',\n    'f': 'v'\n  }\n\n  const keys = {\n    '1': false,\n    '2': false,\n    '3': false,\n    'q': false,\n    'w': false,\n    'e': false,\n    'a': false,\n    's': false,\n    'd': false,\n    'z': false,\n    'x': false,\n    'c': false,\n    '4': false,\n    'r': false,\n    'f': false,\n    'v': false\n  }\n\n  function set (keyPress, value) {\n    keys[keyPress] = value\n  }\n\n  function get (hexKey) {\n    return keys[keyMap[hexKey.toString(16)]]\n  }\n\n  function getAny () {\n    return Object.values(keys).reduce((key, current, index) => {\n      const vmKey = Object.keys(keyMap)[index]\n      if (key) {\n        return key\n      } else if (current) {\n        return vmKey\n      }\n    }, null)\n  }\n\n  return {\n    keyMap,\n    set,\n    get,\n    getAny\n  }\n})()\n\nconst sound = new Audio('./sound.wav')\nconst chip8 = Object(_chip_8__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(keyboard, render, sound)\n\nwindow.addEventListener('keydown', ({ key }) => {\n  if (key === 'm') {\n    sound.play()\n  }\n\n  if (Object.values(keyboard.keyMap).includes(key)) {\n    keyboard.set(key, true)\n  }\n})\n\nwindow.addEventListener('keyup', ({ key }) => {\n  keyboard.set(key, false)\n})\n\ndocument.getElementById('reset').addEventListener('click', _ => {\n  chip8.reset()\n})\n\ndocument.getElementById('game-picker').addEventListener('change', event => {\n  chip8.reset()\n  getGame(event.target.value)\n}, false)\n\nfunction getGame (game) {\n  fetch(`./games/${game}`)\n    .then(response => response.blob())\n    .then(body => {\n      const reader = new FileReader()\n      reader.addEventListener(\"loadend\", _ => loadMemory(reader.result))\n      reader.readAsArrayBuffer(body)\n    })\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixvQkFBb0I7QUFDckMsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHVEQUFLOztBQUVuQixxQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxtQ0FBbUMsTUFBTTtBQUN6QztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDaGlwOCBmcm9tICcuL2NoaXAtOCdcblxuY29uc3QgU0NBTEUgPSAxMFxuXG5mdW5jdGlvbiBsb2FkTWVtb3J5IChmaWxlKSB7XG4gIGNvbnNvbGUubG9nKCdsb2FkaW5nIG1lbW9yeScpXG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZmlsZSlcblxuICBjaGlwOC5zZXRNZW1vcnkoYXJyYXksIDB4MjAwKVxuXG4gIGNoaXA4LnN0YXJ0KClcbn1cblxuY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbmNhbnZhcy5pZCA9ICdjYW52YXMnXG5jYW52YXMud2lkdGggPSA2NCAqIFNDQUxFXG5jYW52YXMuaGVpZ2h0ID0gMzIgKiBTQ0FMRVxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpXG5jb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgY29uc3QgZGlzcGxheSA9IGNoaXA4LmdldERpc3BsYXkoKVxuXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlzcGxheS5sZW5ndGg7IHggKz0gMSkge1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgZGlzcGxheVswXS5sZW5ndGg7IHkgKz0gMSkge1xuICAgICAgY29uc3QgcGl4ZWwgPSBkaXNwbGF5W3hdW3ldXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBpeGVsID8gJyNmZmYnIDogJyMwMDAnXG4gICAgICBjb250ZXh0LmZpbGxSZWN0KHggKiBTQ0FMRSwgeSAqIFNDQUxFLCBTQ0FMRSwgU0NBTEUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRTaW5nbGVGaWxlIChldmVudCkge1xuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJylcbiAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgNjQwLCAzMjAsICcjMDAwJylcblxuICB2YXIgZmlsZW5hbWUgPSBldmVudC50YXJnZXQuZmlsZXNbMF1cblxuICBpZiAoIWZpbGVuYW1lKSByZXR1cm5cblxuICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHJlYWRlci5vbmxvYWQgPSBmaWxlID0+IGxvYWRNZW1vcnkoZmlsZS50YXJnZXQucmVzdWx0KVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZW5hbWUpXG59XG5cbmxldCBrZXlib2FyZCA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGtleU1hcCA9IHtcbiAgICAnMSc6ICcxJyxcbiAgICAnMic6ICcyJyxcbiAgICAnMyc6ICczJyxcbiAgICAnNCc6ICdxJyxcbiAgICAnNSc6ICd3JyxcbiAgICAnNic6ICdlJyxcbiAgICAnNyc6ICdhJyxcbiAgICAnOCc6ICdzJyxcbiAgICAnOSc6ICdkJyxcbiAgICAnYSc6ICd6JyxcbiAgICAnMCc6ICd4JyxcbiAgICAnYic6ICdjJyxcbiAgICAnYyc6ICc0JyxcbiAgICAnZCc6ICdyJyxcbiAgICAnZSc6ICdmJyxcbiAgICAnZic6ICd2J1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IHtcbiAgICAnMSc6IGZhbHNlLFxuICAgICcyJzogZmFsc2UsXG4gICAgJzMnOiBmYWxzZSxcbiAgICAncSc6IGZhbHNlLFxuICAgICd3JzogZmFsc2UsXG4gICAgJ2UnOiBmYWxzZSxcbiAgICAnYSc6IGZhbHNlLFxuICAgICdzJzogZmFsc2UsXG4gICAgJ2QnOiBmYWxzZSxcbiAgICAneic6IGZhbHNlLFxuICAgICd4JzogZmFsc2UsXG4gICAgJ2MnOiBmYWxzZSxcbiAgICAnNCc6IGZhbHNlLFxuICAgICdyJzogZmFsc2UsXG4gICAgJ2YnOiBmYWxzZSxcbiAgICAndic6IGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBzZXQgKGtleVByZXNzLCB2YWx1ZSkge1xuICAgIGtleXNba2V5UHJlc3NdID0gdmFsdWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCAoaGV4S2V5KSB7XG4gICAgcmV0dXJuIGtleXNba2V5TWFwW2hleEtleS50b1N0cmluZygxNildXVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QW55ICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhrZXlzKS5yZWR1Y2UoKGtleSwgY3VycmVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHZtS2V5ID0gT2JqZWN0LmtleXMoa2V5TWFwKVtpbmRleF1cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB2bUtleVxuICAgICAgfVxuICAgIH0sIG51bGwpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGtleU1hcCxcbiAgICBzZXQsXG4gICAgZ2V0LFxuICAgIGdldEFueVxuICB9XG59KSgpXG5cbmNvbnN0IHNvdW5kID0gbmV3IEF1ZGlvKCcuL3NvdW5kLndhdicpXG5jb25zdCBjaGlwOCA9IENoaXA4KGtleWJvYXJkLCByZW5kZXIsIHNvdW5kKVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsICh7IGtleSB9KSA9PiB7XG4gIGlmIChrZXkgPT09ICdtJykge1xuICAgIHNvdW5kLnBsYXkoKVxuICB9XG5cbiAgaWYgKE9iamVjdC52YWx1ZXMoa2V5Ym9hcmQua2V5TWFwKS5pbmNsdWRlcyhrZXkpKSB7XG4gICAga2V5Ym9hcmQuc2V0KGtleSwgdHJ1ZSlcbiAgfVxufSlcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKHsga2V5IH0pID0+IHtcbiAga2V5Ym9hcmQuc2V0KGtleSwgZmFsc2UpXG59KVxuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzZXQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF8gPT4ge1xuICBjaGlwOC5yZXNldCgpXG59KVxuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZS1waWNrZXInKS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBldmVudCA9PiB7XG4gIGNoaXA4LnJlc2V0KClcbiAgZ2V0R2FtZShldmVudC50YXJnZXQudmFsdWUpXG59LCBmYWxzZSlcblxuZnVuY3Rpb24gZ2V0R2FtZSAoZ2FtZSkge1xuICBmZXRjaChgLi9nYW1lcy8ke2dhbWV9YClcbiAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ibG9iKCkpXG4gICAgLnRoZW4oYm9keSA9PiB7XG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlbmRcIiwgXyA9PiBsb2FkTWVtb3J5KHJlYWRlci5yZXN1bHQpKVxuICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJvZHkpXG4gICAgfSlcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ })

/******/ });