/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/chip-8.js":
/*!***********************!*\
  !*** ./src/chip-8.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Made with a loooot of help from this excellent resource: http://devernay.free.fr/hacks/chip8/C8TECH10.HTM\n/* harmony default export */ __webpack_exports__[\"default\"] = ((keyboard, sound) => {\n  const WORD_SIZE = 8\n\n  // It was originally designed to work on 4k computers, so lets give ourselves 4k of memory\n  // 0x0 -> 0x1FF is used to store the system font (it was originally used to store the interpreter data, back when it\n  // was ran on 4k systems)\n  // 0x200 -> 0xFFF is used to store the program data\n  let memory = new Uint8Array(4096)\n\n  // Copied from CowGood's font set\n  const fonts = [\n    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0\n    0x20, 0x60, 0x20, 0x20, 0x70, // 1\n    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2\n    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3\n    0x90, 0x90, 0xF0, 0x10, 0x10, // 4\n    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5\n    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6\n    0xF0, 0x10, 0x20, 0x40, 0x40, // 7\n    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8\n    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9\n    0xF0, 0x90, 0xF0, 0x90, 0x90, // A\n    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B\n    0xF0, 0x80, 0x80, 0x80, 0xF0, // C\n    0xE0, 0x90, 0x90, 0x90, 0xE0, // D\n    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E\n    0xF0, 0x80, 0xF0, 0x80, 0x80 // F\n  ]\n\n  memory.set(fonts, 0)\n\n  let vRegisters = new Uint8Array(16) // It has 16 8-bit data registers. V[0xF] is the carry register.\n  let delayTimer = 0 // When the delay timer hits 0, it stays there.\n  let soundTimer = 0 // When the sound timer hits 0, it stays there, and a monotone sound is played.\n  let pc = 0x200 // And of course a (16-bit) program counter, starting at... 0x200 (where the program is loaded in!)\n  let iRegister = pc // It also has a 16-bit register, usually used for addressing memory\n  let sp = 0 // A stack pointer, allows us to have function calls.\n  let stack = new Array(16) // The stack. Documentation says it's 16 deep, but apparently only 10 are ever used?\n\n  // It utilises a 64x32 pixel display\n  const DISPLAY_WIDTH = 64\n  const DISPLAY_HEIGHT = 32\n  let display = new Array(DISPLAY_WIDTH).fill().map(_ => new Array(DISPLAY_HEIGHT).fill(0))\n  let drawFlag = true\n\n  function setMemory (file, start) {\n    memory.set(file, start)\n  }\n\n  function getDisplay () {\n    return display\n  }\n\n  function reset () {\n    memory = new Uint8Array(4096)\n    vRegisters = new Uint8Array(16)\n    memory.set(fonts, 0)\n    display = new Array(DISPLAY_WIDTH).fill().map(_ => new Array(DISPLAY_HEIGHT).fill(0))\n    pc = 0x200\n    stack = new Array(16)\n    drawFlag = true\n    delayTimer = 0\n    soundTimer = 0\n    iRegister = pc\n  }\n\n  // does a cpu cycle innit.\n  function cycle (delta) {\n    // decrement delayTimer at a rate of 60Hz\n    const timerRefreshRate = 1000 / 60\n    if (delta >= timerRefreshRate) {\n      if (delayTimer > 0) delayTimer -= 1\n\n      if (soundTimer > 0) {\n        soundTimer -= 1\n\n        if (soundTimer === 0) sound.play()\n      }\n    }\n\n    const inst = fetch()\n\n    // decode & execute (i'm too lazy to have them do separately, feels like a waste? We'll see...)\n    decodeAndExecute(inst)\n  }\n\n  // fetching from memory takes twoooo cycles, cos it's an 8-bit bus,\n  // but each instruction is 16-bits long.\n  function fetch () {\n    const inst = (memory[pc] << 8) | memory[pc + 1]\n    pc += 2\n\n    return inst\n  }\n\n  // aight we got a hex value now we need to look up what that means exactly\n  function decodeAndExecute (inst) {\n    // Many of the instructions follow the structure below, so to make my life simpler, I will calculate these values\n    // from the instruction We are using bitmasking to get these values. If you don't quite get what's happening here,\n    // look up https://en.wikipedia.org/wiki/Mask_(computing)\n\n    const nnn = inst & 0x0FFF // nnn or addr - A 12-bit value, the lowest 12 bits of the instruction\n    const n = inst & 0x000F // n or nibble - A 4-bit value, the lowest 4 bits of the instruction\n    const x = (inst & 0x0F00) >> 8 // x - A 4-bit value, the lower 4 bits of the high byte of the instructionction\n    const y = (inst & 0x00F0) >> 4// y - A 4-bit value, the upper 4 bits of the low byte of the instru\n    const kk = inst & 0x00FF // kk or byte - An 8-bit value, the lowest 8 bits of the instruction\n\n    // gonna split this into 'macro level opcodes' and 'micro level opcodes', as the instructions can be indexed by the\n    // highest byte first, and then after that we can decide what to do...\n    const highByte = inst & 0xF000\n    // We... could use a switch statement here, but that would be insane, right? How about a map instead?\n    const macroOpcodes = {\n      0x0000: clearAndReturnOpcodes,\n      0x1000: jump,\n      0x2000: callSubroutine,\n      0x3000: skipIfVxkk,\n      0x4000: skipIfNotVxkk,\n      0x5000: skipIfVxVy,\n      0x6000: loadVxVal,\n      0x7000: addVxVal,\n      0x8000: settingFuncs,\n      0x9000: skipIfNotVxVy,\n      0xA000: loadIAddr,\n      0xB000: jumpV0Offset,\n      0xC000: setVxRandom,\n      0xD000: draw,\n      0xE000: skipKey,\n      0xF000: registerManipulation\n    }\n\n    const macroOpcode = macroOpcodes[highByte]\n\n    macroOpcode({ nnn, n, x, y, kk }) // Yes, very ineffecient right now\n  }\n\n  // 0x0000\n  function clearAndReturnOpcodes (inst) {\n    // is the last bit set? if it is, it's the 'RET' function, otherwise it's the 'CLS' function\n    if (inst.nnn & 0x00F) {\n      returnFromSub() // 0x00EE\n    } else {\n      clearScreen() // 0x00E0\n    }\n\n    // 00E0 - CLS -> Clear the screen\n    function clearScreen () {\n      for (var x = 0; x < display.length; x += 1) {\n        for (var y = 0; y < display[x].length; y += 1) {\n          display[x][y] = 0\n        }\n      }\n    }\n\n    // 00EE - RET\n    // The interpreter sets the program counter to the address at the top of the stack, then subtracts 1 from the stack\n    // pointer. We're doing it the other way around (subtract, THEN set), because otherwise our 'stack's' (which is an\n    // array) first element is never set (stack[0] will never be used)\n    function returnFromSub () {\n      sp -= 1\n      pc = stack[sp]\n    }\n  }\n\n  // 1nnn - JP addr -> Sets pc to nnn\n  function jump (inst) {\n    pc = inst.nnn\n  }\n\n  // 2nnn - CALL addr\n  // Call subroutine at nnn.\n  // The interpreter increments the stack pointer, then puts the current PC on the top of the stack. The PC is then set\n  // to nnn. We're doing this the other way around (set, then increment), see 00EE for more info.\n  function callSubroutine (inst) {\n    stack[sp] = pc\n    sp += 1\n    pc = inst.nnn\n  }\n\n  // 3xkk - SE Vx, byte -> The interpreter compares register Vx to kk, and if they are equal, increments pc by 2.\n  function skipIfVxkk (inst) { // 5xy0 - SE Vx, Vy\n    if (vRegisters[inst.x] === inst.kk) {\n      pc += 2\n    }\n  }\n\n  // 4xkk - SNE Vx, byte\n  // Skip next instruction if Vx != kk.\n  // The interpreter compares register Vx to kk, and if they are not equal, increments the program counter by 2.\n  function skipIfNotVxkk (inst) {\n    if (vRegisters[inst.x] !== inst.kk) {\n      pc += 2\n    }\n  }\n\n  // 5xy0 - SE Vx, Vy\n  // Skip next instruction if Vx = Vy.\n  // The interpreter compares register Vx to register Vy, and if they are equal, increments the program counter by 2.\n  function skipIfVxVy (inst) {\n    if (vRegisters[inst.x] === vRegisters[inst.y]) {\n      pc += 2\n    }\n  }\n\n  // 6xkk - LD Vx, byte\n  // Set Vx = kk.\n  // The interpreter puts the value kk into register Vx.\n  function loadVxVal (inst) {\n    vRegisters[inst.x] = inst.kk\n  }\n\n  // 0x7000\n  // Set Vx = Vx + kk.\n  // Adds the value kk to the value of register Vx, then stores the result in Vx.\n  function addVxVal (inst) {\n    vRegisters[inst.x] = vRegisters[inst.x] + inst.kk\n  }\n\n  // 0x8000\n  function settingFuncs (inst) {\n    const microOpCodes = {\n      0x0: loadVxVy,\n      0x1: vXOrVy,\n      0x3: VxXorVy,\n      0x2: vXAndVy,\n      0x4: vXAddVy,\n      0x5: vXSubVy,\n      0x6: shiftRight,\n      0x7: vYSubVx,\n      0xE: shiftLeft\n    }\n\n    // 8xy0 - LD Vx, Vy -> Vx = Vy\n    function loadVxVy () {\n      vRegisters[inst.x] = vRegisters[inst.y]\n    }\n\n    // 8xy1 - OR Vx, Vy -> Vx = Vx | Vy\n    function vXOrVy () {\n      vRegisters[inst.x] = vRegisters[inst.x] | vRegisters[inst.y]\n    }\n\n    // 8xy2 - AND Vx, Vy -> Vx = Vx & Vy\n    function vXAndVy () {\n      vRegisters[inst.x] = vRegisters[inst.x] & vRegisters[inst.y]\n    }\n\n    // 8xy3 - XOR Vx, Vy -> Set Vx = Vx XOR Vy.\n    function VxXorVy () {\n      vRegisters[inst.x] = vRegisters[inst.x] ^ vRegisters[inst.y]\n    }\n\n    // 8xy4 - ADD Vx, Vy -> Vx = Vx + Vy -> Vx = Vx + Vy, set VF = carry.\n    function vXAddVy () {\n      const result = vRegisters[inst.x] + vRegisters[inst.y]\n\n      if (result > 0xFF) {\n        vRegisters[0xF] = 1\n      } else {\n        vRegisters[0xF] = 0\n      }\n\n      vRegisters[inst.x] = result & 0xFF\n    }\n\n    // 8xy5 - SUB Vx, Vy\n    // Set Vx = Vx - Vy, set VF = NOT borrow.\n    // If Vx > Vy, then VF is set to 1, otherwise 0. Then Vy is subtracted from Vx, and the results stored in Vx.\n    function vXSubVy () {\n      if (vRegisters[inst.x] > vRegisters[inst.y]) {\n        vRegisters[0xF] = 1\n      } else {\n        vRegisters[0xF] = 0\n      }\n\n      vRegisters[inst.x] = (vRegisters[inst.x] - vRegisters[inst.y]) & 0xFF\n    }\n\n    // 8xy6 - SHR Vx {, Vy} -> V[0xF] = Vx & 0x1. Set Vx = Vx >> 1\n    function shiftRight () {\n      vRegisters[0xF] = vRegisters[inst.x] & 0b1\n      vRegisters[inst.x] = vRegisters[inst.x] >> 1\n    }\n\n    // 8xy7 - SUBN Vx, Vy -> Set Vx = Vy - Vx, set VF = NOT borrow.\n    function vYSubVx () {\n      if (vRegisters[inst.y] > vRegisters[inst.x]) {\n        vRegisters[0xF] = 1\n      } else {\n        vRegisters[0xF] = 0\n      }\n\n      vRegisters[inst.x] = vRegisters[inst.y] - vRegisters[inst.x]\n    }\n\n    // 8xyE - SHL Vx {, Vy} -> V[0xF] = 1 if Vx >= 0x80, else 0. Then Vx = Vx << 1.\n    function shiftLeft () {\n      if (vRegisters[inst.x] & 0b10000000) {\n        vRegisters[0xF] = 1\n      } else {\n        vRegisters[0xF] = 0\n      }\n\n      vRegisters[inst.x] = vRegisters[inst.x] << 1\n    }\n\n    if (!microOpCodes[inst.n]) {\n      console.error(`Missing instruction: ${inst.n.toString(16)}`)\n    }\n\n    microOpCodes[inst.n]()\n  }\n\n  // 9xy0 - SNE Vx, Vy -> Skip next instruction if Vx != Vy.\n  function skipIfNotVxVy (inst) {\n    if (vRegisters[inst.x] !== vRegisters[inst.y]) {\n      pc += 2\n    }\n  }\n\n  // 0xA000 -> i = nnn\n  function loadIAddr (inst) {\n    iRegister = inst.nnn\n  }\n\n  // Bnnn - JP V0, addr -> pc = nnn + V0.\n  function jumpV0Offset (inst) {\n    pc = inst.nnn + vRegisters[0]\n  }\n\n  // Cxkk - RND Vx, byte -> Set Vx = random byte AND kk.\n  function setVxRandom (inst) {\n    const random = Math.floor(Math.random(1) * 255)\n    vRegisters[inst.x] = random & inst.kk\n  }\n\n  // Dxyn - DRW Vx, Vy, nibble\n  // Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.\n  // The interpreter reads n bytes from memory, starting at the address stored in I.\n  // These bytes are then displayed as sprites on screen at coordinates (Vx, Vy).\n  // Sprites are XORed onto the existing screen.\n  // If this causes any pixels to be erased, VF is set to 1, otherwise it is set to 0.\n  // If the sprite is positioned so part of it is outside the coordinates of the display, i t wraps around to the\n  // opposite side of the screen.\n  function draw (inst) {\n    let x = vRegisters[inst.x]\n    let y = vRegisters[inst.y]\n    let iAddr = iRegister\n    vRegisters[0xF] = 0\n\n    for (var i = 0; i < inst.n; i += 1) {\n      const newY = (y + i) % DISPLAY_HEIGHT\n\n      const line = memory[iAddr]\n      iAddr += 1\n\n      for (var j = 0; j < WORD_SIZE; j += 1) {\n        const newX = (x + j) % DISPLAY_WIDTH\n\n        const bitmask = 0b00000001 << (WORD_SIZE - 1 - j)\n        const pixel = (line & bitmask) >> (WORD_SIZE - 1 - j)\n\n        const currentPixel = display[newX][newY]\n        const newPixel = currentPixel ^ pixel\n\n        display[newX][newY] = newPixel\n\n        if (currentPixel > newPixel) {\n          vRegisters[0xF] = 1\n        }\n      }\n    }\n\n    drawFlag = true\n  }\n\n  // 0xE000\n  function skipKey (inst) {\n    // Ex9E - SKP Vx -> Skip next instruction if key with the value of Vx is pressed.\n    if (inst.kk === 0x9E) {\n      const isKeyPressed = keyboard.get(vRegisters[inst.x])\n      if (isKeyPressed) {\n        pc += 2\n      }\n      return\n    }\n\n    // ExA1 - SKNP Vx\n    // Skip next instruction if key with the value of Vx is not pressed.\n    // Checks the keyboard, and if the key corresponding to the value of Vx is currently in the up position, PC is\n    // increased by 2.\n    if (inst.kk === 0xA1) {\n      const isKeyPressed = keyboard.get(vRegisters[inst.x])\n      if (!isKeyPressed) {\n        pc += 2\n      }\n    }\n  }\n\n  // 0xF000\n  function registerManipulation (inst) {\n    const microOpCodes = {\n      0x07: loadDelayTimer,\n      0x0A: waitForKeyPress,\n      0x15: setDelayTimer,\n      0x18: setSoundTimer,\n      0x1E: addIVx,\n      0x29: loadIVx,\n      0x33: storeBcd,\n      0x55: loadIV0ToVx,\n      0x65: loadV0ToVxI\n    }\n\n    // Fx07 - LD Vx, DT -> The value of DT is placed into Vx.\n    function loadDelayTimer () {\n      vRegisters[inst.x] = delayTimer\n    }\n\n    // Fx15 - LD DT, Vx -> DT is set equal to the value of Vx.\n    function setDelayTimer () {\n      delayTimer = vRegisters[inst.x]\n    }\n\n    // Fx1E - ADD I, Vx -> Set I = I + Vx.\n    function addIVx () {\n      const value = iRegister + vRegisters[inst.x]\n\n      if (value > 0xFFF) {\n        vRegisters[0xF] = 1\n      } else {\n        vRegisters[0xF] = 0\n      }\n\n      iRegister = value & 0xFFF\n    }\n\n    // Fx29 - LD F, Vx -> Set I = location of sprite for digit Vx.\n    function loadIVx () {\n      iRegister = vRegisters[inst.x] * 5\n    }\n\n    // Fx33 - LD B, Vx\n    // Store BCD representation of Vx in memory locations I, I+1, and I+2.\n    // The interpreter takes the decimal value of Vx, and places the hundreds digit in\n    // memory at location in I, the tens digit at location I+1, and the ones digit at location I+2.\n    function storeBcd () {\n      const dec = vRegisters[inst.x]\n\n      // For a given value, say 234\n      memory[iRegister] = Math.floor(dec / 100) // Gives us 2\n      memory[iRegister + 1] = Math.floor(dec / 10) % 10 // Gives us 3\n      memory[iRegister + 2] = dec % 10 // Gives us 4\n    }\n\n    // Fx55 - LD [I], Vx -> V[0]...V[x] => memory[I]...memory[I + x]\n    function loadIV0ToVx () {\n      for (let i = 0; i <= inst.x; i += 1) {\n        memory[iRegister + i] = vRegisters[i]\n      }\n    }\n\n    // Fx65 - LD Vx, [I] -> The interpreter reads values from memory starting at location I into registers V0 through Vx.\n    function loadV0ToVxI () {\n      for (let i = 0; i <= inst.x; i += 1) {\n        vRegisters[i] = memory[iRegister + i]\n      }\n    }\n\n    // Fx0A - LD Vx, K\n    // Wait for a key press, store the value of the key in Vx.\n    // All execution stops until a key is pressed, then the value of that key is stored in Vx.\n    function waitForKeyPress () {\n      const keyPressed = keyboard.getAny()\n\n      if (!keyPressed) {\n        pc -= 2 // keep looping until a key is pressed\n\n        return\n      }\n\n      vRegisters[inst.x] = keyPressed\n\n      return keyPressed\n    }\n\n    // Fx18 - LD ST, Vx -> Set sound timer = Vx.\n    function setSoundTimer () {\n      soundTimer = vRegisters[inst.x]\n    }\n\n    return microOpCodes[inst.kk]()\n  }\n\n  function getDrawFlag () {\n    return drawFlag\n  }\n\n  return {\n    cycle,\n    getDrawFlag,\n    getDisplay,\n    setMemory,\n    reset\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2hpcC04LmpzPzZmZTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6Qyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsb0JBQW9CO0FBQ2hFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFlBQVk7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsZUFBZTtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL3NyYy9jaGlwLTguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNYWRlIHdpdGggYSBsb29vb3Qgb2YgaGVscCBmcm9tIHRoaXMgZXhjZWxsZW50IHJlc291cmNlOiBodHRwOi8vZGV2ZXJuYXkuZnJlZS5mci9oYWNrcy9jaGlwOC9DOFRFQ0gxMC5IVE1cbmV4cG9ydCBkZWZhdWx0IChrZXlib2FyZCwgc291bmQpID0+IHtcbiAgY29uc3QgV09SRF9TSVpFID0gOFxuXG4gIC8vIEl0IHdhcyBvcmlnaW5hbGx5IGRlc2lnbmVkIHRvIHdvcmsgb24gNGsgY29tcHV0ZXJzLCBzbyBsZXRzIGdpdmUgb3Vyc2VsdmVzIDRrIG9mIG1lbW9yeVxuICAvLyAweDAgLT4gMHgxRkYgaXMgdXNlZCB0byBzdG9yZSB0aGUgc3lzdGVtIGZvbnQgKGl0IHdhcyBvcmlnaW5hbGx5IHVzZWQgdG8gc3RvcmUgdGhlIGludGVycHJldGVyIGRhdGEsIGJhY2sgd2hlbiBpdFxuICAvLyB3YXMgcmFuIG9uIDRrIHN5c3RlbXMpXG4gIC8vIDB4MjAwIC0+IDB4RkZGIGlzIHVzZWQgdG8gc3RvcmUgdGhlIHByb2dyYW0gZGF0YVxuICBsZXQgbWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkoNDA5NilcblxuICAvLyBDb3BpZWQgZnJvbSBDb3dHb29kJ3MgZm9udCBzZXRcbiAgY29uc3QgZm9udHMgPSBbXG4gICAgMHhGMCwgMHg5MCwgMHg5MCwgMHg5MCwgMHhGMCwgLy8gMFxuICAgIDB4MjAsIDB4NjAsIDB4MjAsIDB4MjAsIDB4NzAsIC8vIDFcbiAgICAweEYwLCAweDEwLCAweEYwLCAweDgwLCAweEYwLCAvLyAyXG4gICAgMHhGMCwgMHgxMCwgMHhGMCwgMHgxMCwgMHhGMCwgLy8gM1xuICAgIDB4OTAsIDB4OTAsIDB4RjAsIDB4MTAsIDB4MTAsIC8vIDRcbiAgICAweEYwLCAweDgwLCAweEYwLCAweDEwLCAweEYwLCAvLyA1XG4gICAgMHhGMCwgMHg4MCwgMHhGMCwgMHg5MCwgMHhGMCwgLy8gNlxuICAgIDB4RjAsIDB4MTAsIDB4MjAsIDB4NDAsIDB4NDAsIC8vIDdcbiAgICAweEYwLCAweDkwLCAweEYwLCAweDkwLCAweEYwLCAvLyA4XG4gICAgMHhGMCwgMHg5MCwgMHhGMCwgMHgxMCwgMHhGMCwgLy8gOVxuICAgIDB4RjAsIDB4OTAsIDB4RjAsIDB4OTAsIDB4OTAsIC8vIEFcbiAgICAweEUwLCAweDkwLCAweEUwLCAweDkwLCAweEUwLCAvLyBCXG4gICAgMHhGMCwgMHg4MCwgMHg4MCwgMHg4MCwgMHhGMCwgLy8gQ1xuICAgIDB4RTAsIDB4OTAsIDB4OTAsIDB4OTAsIDB4RTAsIC8vIERcbiAgICAweEYwLCAweDgwLCAweEYwLCAweDgwLCAweEYwLCAvLyBFXG4gICAgMHhGMCwgMHg4MCwgMHhGMCwgMHg4MCwgMHg4MCAvLyBGXG4gIF1cblxuICBtZW1vcnkuc2V0KGZvbnRzLCAwKVxuXG4gIGxldCB2UmVnaXN0ZXJzID0gbmV3IFVpbnQ4QXJyYXkoMTYpIC8vIEl0IGhhcyAxNiA4LWJpdCBkYXRhIHJlZ2lzdGVycy4gVlsweEZdIGlzIHRoZSBjYXJyeSByZWdpc3Rlci5cbiAgbGV0IGRlbGF5VGltZXIgPSAwIC8vIFdoZW4gdGhlIGRlbGF5IHRpbWVyIGhpdHMgMCwgaXQgc3RheXMgdGhlcmUuXG4gIGxldCBzb3VuZFRpbWVyID0gMCAvLyBXaGVuIHRoZSBzb3VuZCB0aW1lciBoaXRzIDAsIGl0IHN0YXlzIHRoZXJlLCBhbmQgYSBtb25vdG9uZSBzb3VuZCBpcyBwbGF5ZWQuXG4gIGxldCBwYyA9IDB4MjAwIC8vIEFuZCBvZiBjb3Vyc2UgYSAoMTYtYml0KSBwcm9ncmFtIGNvdW50ZXIsIHN0YXJ0aW5nIGF0Li4uIDB4MjAwICh3aGVyZSB0aGUgcHJvZ3JhbSBpcyBsb2FkZWQgaW4hKVxuICBsZXQgaVJlZ2lzdGVyID0gcGMgLy8gSXQgYWxzbyBoYXMgYSAxNi1iaXQgcmVnaXN0ZXIsIHVzdWFsbHkgdXNlZCBmb3IgYWRkcmVzc2luZyBtZW1vcnlcbiAgbGV0IHNwID0gMCAvLyBBIHN0YWNrIHBvaW50ZXIsIGFsbG93cyB1cyB0byBoYXZlIGZ1bmN0aW9uIGNhbGxzLlxuICBsZXQgc3RhY2sgPSBuZXcgQXJyYXkoMTYpIC8vIFRoZSBzdGFjay4gRG9jdW1lbnRhdGlvbiBzYXlzIGl0J3MgMTYgZGVlcCwgYnV0IGFwcGFyZW50bHkgb25seSAxMCBhcmUgZXZlciB1c2VkP1xuXG4gIC8vIEl0IHV0aWxpc2VzIGEgNjR4MzIgcGl4ZWwgZGlzcGxheVxuICBjb25zdCBESVNQTEFZX1dJRFRIID0gNjRcbiAgY29uc3QgRElTUExBWV9IRUlHSFQgPSAzMlxuICBsZXQgZGlzcGxheSA9IG5ldyBBcnJheShESVNQTEFZX1dJRFRIKS5maWxsKCkubWFwKF8gPT4gbmV3IEFycmF5KERJU1BMQVlfSEVJR0hUKS5maWxsKDApKVxuICBsZXQgZHJhd0ZsYWcgPSB0cnVlXG5cbiAgZnVuY3Rpb24gc2V0TWVtb3J5IChmaWxlLCBzdGFydCkge1xuICAgIG1lbW9yeS5zZXQoZmlsZSwgc3RhcnQpXG4gIH1cblxuICBmdW5jdGlvbiBnZXREaXNwbGF5ICgpIHtcbiAgICByZXR1cm4gZGlzcGxheVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXQgKCkge1xuICAgIG1lbW9yeSA9IG5ldyBVaW50OEFycmF5KDQwOTYpXG4gICAgdlJlZ2lzdGVycyA9IG5ldyBVaW50OEFycmF5KDE2KVxuICAgIG1lbW9yeS5zZXQoZm9udHMsIDApXG4gICAgZGlzcGxheSA9IG5ldyBBcnJheShESVNQTEFZX1dJRFRIKS5maWxsKCkubWFwKF8gPT4gbmV3IEFycmF5KERJU1BMQVlfSEVJR0hUKS5maWxsKDApKVxuICAgIHBjID0gMHgyMDBcbiAgICBzdGFjayA9IG5ldyBBcnJheSgxNilcbiAgICBkcmF3RmxhZyA9IHRydWVcbiAgICBkZWxheVRpbWVyID0gMFxuICAgIHNvdW5kVGltZXIgPSAwXG4gICAgaVJlZ2lzdGVyID0gcGNcbiAgfVxuXG4gIC8vIGRvZXMgYSBjcHUgY3ljbGUgaW5uaXQuXG4gIGZ1bmN0aW9uIGN5Y2xlIChkZWx0YSkge1xuICAgIC8vIGRlY3JlbWVudCBkZWxheVRpbWVyIGF0IGEgcmF0ZSBvZiA2MEh6XG4gICAgY29uc3QgdGltZXJSZWZyZXNoUmF0ZSA9IDEwMDAgLyA2MFxuICAgIGlmIChkZWx0YSA+PSB0aW1lclJlZnJlc2hSYXRlKSB7XG4gICAgICBpZiAoZGVsYXlUaW1lciA+IDApIGRlbGF5VGltZXIgLT0gMVxuXG4gICAgICBpZiAoc291bmRUaW1lciA+IDApIHtcbiAgICAgICAgc291bmRUaW1lciAtPSAxXG5cbiAgICAgICAgaWYgKHNvdW5kVGltZXIgPT09IDApIHNvdW5kLnBsYXkoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGluc3QgPSBmZXRjaCgpXG5cbiAgICAvLyBkZWNvZGUgJiBleGVjdXRlIChpJ20gdG9vIGxhenkgdG8gaGF2ZSB0aGVtIGRvIHNlcGFyYXRlbHksIGZlZWxzIGxpa2UgYSB3YXN0ZT8gV2UnbGwgc2VlLi4uKVxuICAgIGRlY29kZUFuZEV4ZWN1dGUoaW5zdClcbiAgfVxuXG4gIC8vIGZldGNoaW5nIGZyb20gbWVtb3J5IHRha2VzIHR3b29vbyBjeWNsZXMsIGNvcyBpdCdzIGFuIDgtYml0IGJ1cyxcbiAgLy8gYnV0IGVhY2ggaW5zdHJ1Y3Rpb24gaXMgMTYtYml0cyBsb25nLlxuICBmdW5jdGlvbiBmZXRjaCAoKSB7XG4gICAgY29uc3QgaW5zdCA9IChtZW1vcnlbcGNdIDw8IDgpIHwgbWVtb3J5W3BjICsgMV1cbiAgICBwYyArPSAyXG5cbiAgICByZXR1cm4gaW5zdFxuICB9XG5cbiAgLy8gYWlnaHQgd2UgZ290IGEgaGV4IHZhbHVlIG5vdyB3ZSBuZWVkIHRvIGxvb2sgdXAgd2hhdCB0aGF0IG1lYW5zIGV4YWN0bHlcbiAgZnVuY3Rpb24gZGVjb2RlQW5kRXhlY3V0ZSAoaW5zdCkge1xuICAgIC8vIE1hbnkgb2YgdGhlIGluc3RydWN0aW9ucyBmb2xsb3cgdGhlIHN0cnVjdHVyZSBiZWxvdywgc28gdG8gbWFrZSBteSBsaWZlIHNpbXBsZXIsIEkgd2lsbCBjYWxjdWxhdGUgdGhlc2UgdmFsdWVzXG4gICAgLy8gZnJvbSB0aGUgaW5zdHJ1Y3Rpb24gV2UgYXJlIHVzaW5nIGJpdG1hc2tpbmcgdG8gZ2V0IHRoZXNlIHZhbHVlcy4gSWYgeW91IGRvbid0IHF1aXRlIGdldCB3aGF0J3MgaGFwcGVuaW5nIGhlcmUsXG4gICAgLy8gbG9vayB1cCBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXNrXyhjb21wdXRpbmcpXG5cbiAgICBjb25zdCBubm4gPSBpbnN0ICYgMHgwRkZGIC8vIG5ubiBvciBhZGRyIC0gQSAxMi1iaXQgdmFsdWUsIHRoZSBsb3dlc3QgMTIgYml0cyBvZiB0aGUgaW5zdHJ1Y3Rpb25cbiAgICBjb25zdCBuID0gaW5zdCAmIDB4MDAwRiAvLyBuIG9yIG5pYmJsZSAtIEEgNC1iaXQgdmFsdWUsIHRoZSBsb3dlc3QgNCBiaXRzIG9mIHRoZSBpbnN0cnVjdGlvblxuICAgIGNvbnN0IHggPSAoaW5zdCAmIDB4MEYwMCkgPj4gOCAvLyB4IC0gQSA0LWJpdCB2YWx1ZSwgdGhlIGxvd2VyIDQgYml0cyBvZiB0aGUgaGlnaCBieXRlIG9mIHRoZSBpbnN0cnVjdGlvbmN0aW9uXG4gICAgY29uc3QgeSA9IChpbnN0ICYgMHgwMEYwKSA+PiA0Ly8geSAtIEEgNC1iaXQgdmFsdWUsIHRoZSB1cHBlciA0IGJpdHMgb2YgdGhlIGxvdyBieXRlIG9mIHRoZSBpbnN0cnVcbiAgICBjb25zdCBrayA9IGluc3QgJiAweDAwRkYgLy8ga2sgb3IgYnl0ZSAtIEFuIDgtYml0IHZhbHVlLCB0aGUgbG93ZXN0IDggYml0cyBvZiB0aGUgaW5zdHJ1Y3Rpb25cblxuICAgIC8vIGdvbm5hIHNwbGl0IHRoaXMgaW50byAnbWFjcm8gbGV2ZWwgb3Bjb2RlcycgYW5kICdtaWNybyBsZXZlbCBvcGNvZGVzJywgYXMgdGhlIGluc3RydWN0aW9ucyBjYW4gYmUgaW5kZXhlZCBieSB0aGVcbiAgICAvLyBoaWdoZXN0IGJ5dGUgZmlyc3QsIGFuZCB0aGVuIGFmdGVyIHRoYXQgd2UgY2FuIGRlY2lkZSB3aGF0IHRvIGRvLi4uXG4gICAgY29uc3QgaGlnaEJ5dGUgPSBpbnN0ICYgMHhGMDAwXG4gICAgLy8gV2UuLi4gY291bGQgdXNlIGEgc3dpdGNoIHN0YXRlbWVudCBoZXJlLCBidXQgdGhhdCB3b3VsZCBiZSBpbnNhbmUsIHJpZ2h0PyBIb3cgYWJvdXQgYSBtYXAgaW5zdGVhZD9cbiAgICBjb25zdCBtYWNyb09wY29kZXMgPSB7XG4gICAgICAweDAwMDA6IGNsZWFyQW5kUmV0dXJuT3Bjb2RlcyxcbiAgICAgIDB4MTAwMDoganVtcCxcbiAgICAgIDB4MjAwMDogY2FsbFN1YnJvdXRpbmUsXG4gICAgICAweDMwMDA6IHNraXBJZlZ4a2ssXG4gICAgICAweDQwMDA6IHNraXBJZk5vdFZ4a2ssXG4gICAgICAweDUwMDA6IHNraXBJZlZ4VnksXG4gICAgICAweDYwMDA6IGxvYWRWeFZhbCxcbiAgICAgIDB4NzAwMDogYWRkVnhWYWwsXG4gICAgICAweDgwMDA6IHNldHRpbmdGdW5jcyxcbiAgICAgIDB4OTAwMDogc2tpcElmTm90VnhWeSxcbiAgICAgIDB4QTAwMDogbG9hZElBZGRyLFxuICAgICAgMHhCMDAwOiBqdW1wVjBPZmZzZXQsXG4gICAgICAweEMwMDA6IHNldFZ4UmFuZG9tLFxuICAgICAgMHhEMDAwOiBkcmF3LFxuICAgICAgMHhFMDAwOiBza2lwS2V5LFxuICAgICAgMHhGMDAwOiByZWdpc3Rlck1hbmlwdWxhdGlvblxuICAgIH1cblxuICAgIGNvbnN0IG1hY3JvT3Bjb2RlID0gbWFjcm9PcGNvZGVzW2hpZ2hCeXRlXVxuXG4gICAgbWFjcm9PcGNvZGUoeyBubm4sIG4sIHgsIHksIGtrIH0pIC8vIFllcywgdmVyeSBpbmVmZmVjaWVudCByaWdodCBub3dcbiAgfVxuXG4gIC8vIDB4MDAwMFxuICBmdW5jdGlvbiBjbGVhckFuZFJldHVybk9wY29kZXMgKGluc3QpIHtcbiAgICAvLyBpcyB0aGUgbGFzdCBiaXQgc2V0PyBpZiBpdCBpcywgaXQncyB0aGUgJ1JFVCcgZnVuY3Rpb24sIG90aGVyd2lzZSBpdCdzIHRoZSAnQ0xTJyBmdW5jdGlvblxuICAgIGlmIChpbnN0Lm5ubiAmIDB4MDBGKSB7XG4gICAgICByZXR1cm5Gcm9tU3ViKCkgLy8gMHgwMEVFXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyU2NyZWVuKCkgLy8gMHgwMEUwXG4gICAgfVxuXG4gICAgLy8gMDBFMCAtIENMUyAtPiBDbGVhciB0aGUgc2NyZWVuXG4gICAgZnVuY3Rpb24gY2xlYXJTY3JlZW4gKCkge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBkaXNwbGF5Lmxlbmd0aDsgeCArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgZGlzcGxheVt4XS5sZW5ndGg7IHkgKz0gMSkge1xuICAgICAgICAgIGRpc3BsYXlbeF1beV0gPSAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAwMEVFIC0gUkVUXG4gICAgLy8gVGhlIGludGVycHJldGVyIHNldHMgdGhlIHByb2dyYW0gY291bnRlciB0byB0aGUgYWRkcmVzcyBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjaywgdGhlbiBzdWJ0cmFjdHMgMSBmcm9tIHRoZSBzdGFja1xuICAgIC8vIHBvaW50ZXIuIFdlJ3JlIGRvaW5nIGl0IHRoZSBvdGhlciB3YXkgYXJvdW5kIChzdWJ0cmFjdCwgVEhFTiBzZXQpLCBiZWNhdXNlIG90aGVyd2lzZSBvdXIgJ3N0YWNrJ3MnICh3aGljaCBpcyBhblxuICAgIC8vIGFycmF5KSBmaXJzdCBlbGVtZW50IGlzIG5ldmVyIHNldCAoc3RhY2tbMF0gd2lsbCBuZXZlciBiZSB1c2VkKVxuICAgIGZ1bmN0aW9uIHJldHVybkZyb21TdWIgKCkge1xuICAgICAgc3AgLT0gMVxuICAgICAgcGMgPSBzdGFja1tzcF1cbiAgICB9XG4gIH1cblxuICAvLyAxbm5uIC0gSlAgYWRkciAtPiBTZXRzIHBjIHRvIG5ublxuICBmdW5jdGlvbiBqdW1wIChpbnN0KSB7XG4gICAgcGMgPSBpbnN0Lm5ublxuICB9XG5cbiAgLy8gMm5ubiAtIENBTEwgYWRkclxuICAvLyBDYWxsIHN1YnJvdXRpbmUgYXQgbm5uLlxuICAvLyBUaGUgaW50ZXJwcmV0ZXIgaW5jcmVtZW50cyB0aGUgc3RhY2sgcG9pbnRlciwgdGhlbiBwdXRzIHRoZSBjdXJyZW50IFBDIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrLiBUaGUgUEMgaXMgdGhlbiBzZXRcbiAgLy8gdG8gbm5uLiBXZSdyZSBkb2luZyB0aGlzIHRoZSBvdGhlciB3YXkgYXJvdW5kIChzZXQsIHRoZW4gaW5jcmVtZW50KSwgc2VlIDAwRUUgZm9yIG1vcmUgaW5mby5cbiAgZnVuY3Rpb24gY2FsbFN1YnJvdXRpbmUgKGluc3QpIHtcbiAgICBzdGFja1tzcF0gPSBwY1xuICAgIHNwICs9IDFcbiAgICBwYyA9IGluc3Qubm5uXG4gIH1cblxuICAvLyAzeGtrIC0gU0UgVngsIGJ5dGUgLT4gVGhlIGludGVycHJldGVyIGNvbXBhcmVzIHJlZ2lzdGVyIFZ4IHRvIGtrLCBhbmQgaWYgdGhleSBhcmUgZXF1YWwsIGluY3JlbWVudHMgcGMgYnkgMi5cbiAgZnVuY3Rpb24gc2tpcElmVnhrayAoaW5zdCkgeyAvLyA1eHkwIC0gU0UgVngsIFZ5XG4gICAgaWYgKHZSZWdpc3RlcnNbaW5zdC54XSA9PT0gaW5zdC5raykge1xuICAgICAgcGMgKz0gMlxuICAgIH1cbiAgfVxuXG4gIC8vIDR4a2sgLSBTTkUgVngsIGJ5dGVcbiAgLy8gU2tpcCBuZXh0IGluc3RydWN0aW9uIGlmIFZ4ICE9IGtrLlxuICAvLyBUaGUgaW50ZXJwcmV0ZXIgY29tcGFyZXMgcmVnaXN0ZXIgVnggdG8ga2ssIGFuZCBpZiB0aGV5IGFyZSBub3QgZXF1YWwsIGluY3JlbWVudHMgdGhlIHByb2dyYW0gY291bnRlciBieSAyLlxuICBmdW5jdGlvbiBza2lwSWZOb3RWeGtrIChpbnN0KSB7XG4gICAgaWYgKHZSZWdpc3RlcnNbaW5zdC54XSAhPT0gaW5zdC5raykge1xuICAgICAgcGMgKz0gMlxuICAgIH1cbiAgfVxuXG4gIC8vIDV4eTAgLSBTRSBWeCwgVnlcbiAgLy8gU2tpcCBuZXh0IGluc3RydWN0aW9uIGlmIFZ4ID0gVnkuXG4gIC8vIFRoZSBpbnRlcnByZXRlciBjb21wYXJlcyByZWdpc3RlciBWeCB0byByZWdpc3RlciBWeSwgYW5kIGlmIHRoZXkgYXJlIGVxdWFsLCBpbmNyZW1lbnRzIHRoZSBwcm9ncmFtIGNvdW50ZXIgYnkgMi5cbiAgZnVuY3Rpb24gc2tpcElmVnhWeSAoaW5zdCkge1xuICAgIGlmICh2UmVnaXN0ZXJzW2luc3QueF0gPT09IHZSZWdpc3RlcnNbaW5zdC55XSkge1xuICAgICAgcGMgKz0gMlxuICAgIH1cbiAgfVxuXG4gIC8vIDZ4a2sgLSBMRCBWeCwgYnl0ZVxuICAvLyBTZXQgVnggPSBray5cbiAgLy8gVGhlIGludGVycHJldGVyIHB1dHMgdGhlIHZhbHVlIGtrIGludG8gcmVnaXN0ZXIgVnguXG4gIGZ1bmN0aW9uIGxvYWRWeFZhbCAoaW5zdCkge1xuICAgIHZSZWdpc3RlcnNbaW5zdC54XSA9IGluc3Qua2tcbiAgfVxuXG4gIC8vIDB4NzAwMFxuICAvLyBTZXQgVnggPSBWeCArIGtrLlxuICAvLyBBZGRzIHRoZSB2YWx1ZSBrayB0byB0aGUgdmFsdWUgb2YgcmVnaXN0ZXIgVngsIHRoZW4gc3RvcmVzIHRoZSByZXN1bHQgaW4gVnguXG4gIGZ1bmN0aW9uIGFkZFZ4VmFsIChpbnN0KSB7XG4gICAgdlJlZ2lzdGVyc1tpbnN0LnhdID0gdlJlZ2lzdGVyc1tpbnN0LnhdICsgaW5zdC5ra1xuICB9XG5cbiAgLy8gMHg4MDAwXG4gIGZ1bmN0aW9uIHNldHRpbmdGdW5jcyAoaW5zdCkge1xuICAgIGNvbnN0IG1pY3JvT3BDb2RlcyA9IHtcbiAgICAgIDB4MDogbG9hZFZ4VnksXG4gICAgICAweDE6IHZYT3JWeSxcbiAgICAgIDB4MzogVnhYb3JWeSxcbiAgICAgIDB4MjogdlhBbmRWeSxcbiAgICAgIDB4NDogdlhBZGRWeSxcbiAgICAgIDB4NTogdlhTdWJWeSxcbiAgICAgIDB4Njogc2hpZnRSaWdodCxcbiAgICAgIDB4NzogdllTdWJWeCxcbiAgICAgIDB4RTogc2hpZnRMZWZ0XG4gICAgfVxuXG4gICAgLy8gOHh5MCAtIExEIFZ4LCBWeSAtPiBWeCA9IFZ5XG4gICAgZnVuY3Rpb24gbG9hZFZ4VnkgKCkge1xuICAgICAgdlJlZ2lzdGVyc1tpbnN0LnhdID0gdlJlZ2lzdGVyc1tpbnN0LnldXG4gICAgfVxuXG4gICAgLy8gOHh5MSAtIE9SIFZ4LCBWeSAtPiBWeCA9IFZ4IHwgVnlcbiAgICBmdW5jdGlvbiB2WE9yVnkgKCkge1xuICAgICAgdlJlZ2lzdGVyc1tpbnN0LnhdID0gdlJlZ2lzdGVyc1tpbnN0LnhdIHwgdlJlZ2lzdGVyc1tpbnN0LnldXG4gICAgfVxuXG4gICAgLy8gOHh5MiAtIEFORCBWeCwgVnkgLT4gVnggPSBWeCAmIFZ5XG4gICAgZnVuY3Rpb24gdlhBbmRWeSAoKSB7XG4gICAgICB2UmVnaXN0ZXJzW2luc3QueF0gPSB2UmVnaXN0ZXJzW2luc3QueF0gJiB2UmVnaXN0ZXJzW2luc3QueV1cbiAgICB9XG5cbiAgICAvLyA4eHkzIC0gWE9SIFZ4LCBWeSAtPiBTZXQgVnggPSBWeCBYT1IgVnkuXG4gICAgZnVuY3Rpb24gVnhYb3JWeSAoKSB7XG4gICAgICB2UmVnaXN0ZXJzW2luc3QueF0gPSB2UmVnaXN0ZXJzW2luc3QueF0gXiB2UmVnaXN0ZXJzW2luc3QueV1cbiAgICB9XG5cbiAgICAvLyA4eHk0IC0gQUREIFZ4LCBWeSAtPiBWeCA9IFZ4ICsgVnkgLT4gVnggPSBWeCArIFZ5LCBzZXQgVkYgPSBjYXJyeS5cbiAgICBmdW5jdGlvbiB2WEFkZFZ5ICgpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZSZWdpc3RlcnNbaW5zdC54XSArIHZSZWdpc3RlcnNbaW5zdC55XVxuXG4gICAgICBpZiAocmVzdWx0ID4gMHhGRikge1xuICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAwXG4gICAgICB9XG5cbiAgICAgIHZSZWdpc3RlcnNbaW5zdC54XSA9IHJlc3VsdCAmIDB4RkZcbiAgICB9XG5cbiAgICAvLyA4eHk1IC0gU1VCIFZ4LCBWeVxuICAgIC8vIFNldCBWeCA9IFZ4IC0gVnksIHNldCBWRiA9IE5PVCBib3Jyb3cuXG4gICAgLy8gSWYgVnggPiBWeSwgdGhlbiBWRiBpcyBzZXQgdG8gMSwgb3RoZXJ3aXNlIDAuIFRoZW4gVnkgaXMgc3VidHJhY3RlZCBmcm9tIFZ4LCBhbmQgdGhlIHJlc3VsdHMgc3RvcmVkIGluIFZ4LlxuICAgIGZ1bmN0aW9uIHZYU3ViVnkgKCkge1xuICAgICAgaWYgKHZSZWdpc3RlcnNbaW5zdC54XSA+IHZSZWdpc3RlcnNbaW5zdC55XSkge1xuICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAwXG4gICAgICB9XG5cbiAgICAgIHZSZWdpc3RlcnNbaW5zdC54XSA9ICh2UmVnaXN0ZXJzW2luc3QueF0gLSB2UmVnaXN0ZXJzW2luc3QueV0pICYgMHhGRlxuICAgIH1cblxuICAgIC8vIDh4eTYgLSBTSFIgVnggeywgVnl9IC0+IFZbMHhGXSA9IFZ4ICYgMHgxLiBTZXQgVnggPSBWeCA+PiAxXG4gICAgZnVuY3Rpb24gc2hpZnRSaWdodCAoKSB7XG4gICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSB2UmVnaXN0ZXJzW2luc3QueF0gJiAwYjFcbiAgICAgIHZSZWdpc3RlcnNbaW5zdC54XSA9IHZSZWdpc3RlcnNbaW5zdC54XSA+PiAxXG4gICAgfVxuXG4gICAgLy8gOHh5NyAtIFNVQk4gVngsIFZ5IC0+IFNldCBWeCA9IFZ5IC0gVngsIHNldCBWRiA9IE5PVCBib3Jyb3cuXG4gICAgZnVuY3Rpb24gdllTdWJWeCAoKSB7XG4gICAgICBpZiAodlJlZ2lzdGVyc1tpbnN0LnldID4gdlJlZ2lzdGVyc1tpbnN0LnhdKSB7XG4gICAgICAgIHZSZWdpc3RlcnNbMHhGXSA9IDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZSZWdpc3RlcnNbMHhGXSA9IDBcbiAgICAgIH1cblxuICAgICAgdlJlZ2lzdGVyc1tpbnN0LnhdID0gdlJlZ2lzdGVyc1tpbnN0LnldIC0gdlJlZ2lzdGVyc1tpbnN0LnhdXG4gICAgfVxuXG4gICAgLy8gOHh5RSAtIFNITCBWeCB7LCBWeX0gLT4gVlsweEZdID0gMSBpZiBWeCA+PSAweDgwLCBlbHNlIDAuIFRoZW4gVnggPSBWeCA8PCAxLlxuICAgIGZ1bmN0aW9uIHNoaWZ0TGVmdCAoKSB7XG4gICAgICBpZiAodlJlZ2lzdGVyc1tpbnN0LnhdICYgMGIxMDAwMDAwMCkge1xuICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAwXG4gICAgICB9XG5cbiAgICAgIHZSZWdpc3RlcnNbaW5zdC54XSA9IHZSZWdpc3RlcnNbaW5zdC54XSA8PCAxXG4gICAgfVxuXG4gICAgaWYgKCFtaWNyb09wQ29kZXNbaW5zdC5uXSkge1xuICAgICAgY29uc29sZS5lcnJvcihgTWlzc2luZyBpbnN0cnVjdGlvbjogJHtpbnN0Lm4udG9TdHJpbmcoMTYpfWApXG4gICAgfVxuXG4gICAgbWljcm9PcENvZGVzW2luc3Qubl0oKVxuICB9XG5cbiAgLy8gOXh5MCAtIFNORSBWeCwgVnkgLT4gU2tpcCBuZXh0IGluc3RydWN0aW9uIGlmIFZ4ICE9IFZ5LlxuICBmdW5jdGlvbiBza2lwSWZOb3RWeFZ5IChpbnN0KSB7XG4gICAgaWYgKHZSZWdpc3RlcnNbaW5zdC54XSAhPT0gdlJlZ2lzdGVyc1tpbnN0LnldKSB7XG4gICAgICBwYyArPSAyXG4gICAgfVxuICB9XG5cbiAgLy8gMHhBMDAwIC0+IGkgPSBubm5cbiAgZnVuY3Rpb24gbG9hZElBZGRyIChpbnN0KSB7XG4gICAgaVJlZ2lzdGVyID0gaW5zdC5ubm5cbiAgfVxuXG4gIC8vIEJubm4gLSBKUCBWMCwgYWRkciAtPiBwYyA9IG5ubiArIFYwLlxuICBmdW5jdGlvbiBqdW1wVjBPZmZzZXQgKGluc3QpIHtcbiAgICBwYyA9IGluc3Qubm5uICsgdlJlZ2lzdGVyc1swXVxuICB9XG5cbiAgLy8gQ3hrayAtIFJORCBWeCwgYnl0ZSAtPiBTZXQgVnggPSByYW5kb20gYnl0ZSBBTkQga2suXG4gIGZ1bmN0aW9uIHNldFZ4UmFuZG9tIChpbnN0KSB7XG4gICAgY29uc3QgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgxKSAqIDI1NSlcbiAgICB2UmVnaXN0ZXJzW2luc3QueF0gPSByYW5kb20gJiBpbnN0LmtrXG4gIH1cblxuICAvLyBEeHluIC0gRFJXIFZ4LCBWeSwgbmliYmxlXG4gIC8vIERpc3BsYXkgbi1ieXRlIHNwcml0ZSBzdGFydGluZyBhdCBtZW1vcnkgbG9jYXRpb24gSSBhdCAoVngsIFZ5KSwgc2V0IFZGID0gY29sbGlzaW9uLlxuICAvLyBUaGUgaW50ZXJwcmV0ZXIgcmVhZHMgbiBieXRlcyBmcm9tIG1lbW9yeSwgc3RhcnRpbmcgYXQgdGhlIGFkZHJlc3Mgc3RvcmVkIGluIEkuXG4gIC8vIFRoZXNlIGJ5dGVzIGFyZSB0aGVuIGRpc3BsYXllZCBhcyBzcHJpdGVzIG9uIHNjcmVlbiBhdCBjb29yZGluYXRlcyAoVngsIFZ5KS5cbiAgLy8gU3ByaXRlcyBhcmUgWE9SZWQgb250byB0aGUgZXhpc3Rpbmcgc2NyZWVuLlxuICAvLyBJZiB0aGlzIGNhdXNlcyBhbnkgcGl4ZWxzIHRvIGJlIGVyYXNlZCwgVkYgaXMgc2V0IHRvIDEsIG90aGVyd2lzZSBpdCBpcyBzZXQgdG8gMC5cbiAgLy8gSWYgdGhlIHNwcml0ZSBpcyBwb3NpdGlvbmVkIHNvIHBhcnQgb2YgaXQgaXMgb3V0c2lkZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGRpc3BsYXksIGkgdCB3cmFwcyBhcm91bmQgdG8gdGhlXG4gIC8vIG9wcG9zaXRlIHNpZGUgb2YgdGhlIHNjcmVlbi5cbiAgZnVuY3Rpb24gZHJhdyAoaW5zdCkge1xuICAgIGxldCB4ID0gdlJlZ2lzdGVyc1tpbnN0LnhdXG4gICAgbGV0IHkgPSB2UmVnaXN0ZXJzW2luc3QueV1cbiAgICBsZXQgaUFkZHIgPSBpUmVnaXN0ZXJcbiAgICB2UmVnaXN0ZXJzWzB4Rl0gPSAwXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3QubjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBuZXdZID0gKHkgKyBpKSAlIERJU1BMQVlfSEVJR0hUXG5cbiAgICAgIGNvbnN0IGxpbmUgPSBtZW1vcnlbaUFkZHJdXG4gICAgICBpQWRkciArPSAxXG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgV09SRF9TSVpFOyBqICs9IDEpIHtcbiAgICAgICAgY29uc3QgbmV3WCA9ICh4ICsgaikgJSBESVNQTEFZX1dJRFRIXG5cbiAgICAgICAgY29uc3QgYml0bWFzayA9IDBiMDAwMDAwMDEgPDwgKFdPUkRfU0laRSAtIDEgLSBqKVxuICAgICAgICBjb25zdCBwaXhlbCA9IChsaW5lICYgYml0bWFzaykgPj4gKFdPUkRfU0laRSAtIDEgLSBqKVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQaXhlbCA9IGRpc3BsYXlbbmV3WF1bbmV3WV1cbiAgICAgICAgY29uc3QgbmV3UGl4ZWwgPSBjdXJyZW50UGl4ZWwgXiBwaXhlbFxuXG4gICAgICAgIGRpc3BsYXlbbmV3WF1bbmV3WV0gPSBuZXdQaXhlbFxuXG4gICAgICAgIGlmIChjdXJyZW50UGl4ZWwgPiBuZXdQaXhlbCkge1xuICAgICAgICAgIHZSZWdpc3RlcnNbMHhGXSA9IDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRyYXdGbGFnID0gdHJ1ZVxuICB9XG5cbiAgLy8gMHhFMDAwXG4gIGZ1bmN0aW9uIHNraXBLZXkgKGluc3QpIHtcbiAgICAvLyBFeDlFIC0gU0tQIFZ4IC0+IFNraXAgbmV4dCBpbnN0cnVjdGlvbiBpZiBrZXkgd2l0aCB0aGUgdmFsdWUgb2YgVnggaXMgcHJlc3NlZC5cbiAgICBpZiAoaW5zdC5rayA9PT0gMHg5RSkge1xuICAgICAgY29uc3QgaXNLZXlQcmVzc2VkID0ga2V5Ym9hcmQuZ2V0KHZSZWdpc3RlcnNbaW5zdC54XSlcbiAgICAgIGlmIChpc0tleVByZXNzZWQpIHtcbiAgICAgICAgcGMgKz0gMlxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRXhBMSAtIFNLTlAgVnhcbiAgICAvLyBTa2lwIG5leHQgaW5zdHJ1Y3Rpb24gaWYga2V5IHdpdGggdGhlIHZhbHVlIG9mIFZ4IGlzIG5vdCBwcmVzc2VkLlxuICAgIC8vIENoZWNrcyB0aGUga2V5Ym9hcmQsIGFuZCBpZiB0aGUga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZhbHVlIG9mIFZ4IGlzIGN1cnJlbnRseSBpbiB0aGUgdXAgcG9zaXRpb24sIFBDIGlzXG4gICAgLy8gaW5jcmVhc2VkIGJ5IDIuXG4gICAgaWYgKGluc3Qua2sgPT09IDB4QTEpIHtcbiAgICAgIGNvbnN0IGlzS2V5UHJlc3NlZCA9IGtleWJvYXJkLmdldCh2UmVnaXN0ZXJzW2luc3QueF0pXG4gICAgICBpZiAoIWlzS2V5UHJlc3NlZCkge1xuICAgICAgICBwYyArPSAyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMHhGMDAwXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTWFuaXB1bGF0aW9uIChpbnN0KSB7XG4gICAgY29uc3QgbWljcm9PcENvZGVzID0ge1xuICAgICAgMHgwNzogbG9hZERlbGF5VGltZXIsXG4gICAgICAweDBBOiB3YWl0Rm9yS2V5UHJlc3MsXG4gICAgICAweDE1OiBzZXREZWxheVRpbWVyLFxuICAgICAgMHgxODogc2V0U291bmRUaW1lcixcbiAgICAgIDB4MUU6IGFkZElWeCxcbiAgICAgIDB4Mjk6IGxvYWRJVngsXG4gICAgICAweDMzOiBzdG9yZUJjZCxcbiAgICAgIDB4NTU6IGxvYWRJVjBUb1Z4LFxuICAgICAgMHg2NTogbG9hZFYwVG9WeElcbiAgICB9XG5cbiAgICAvLyBGeDA3IC0gTEQgVngsIERUIC0+IFRoZSB2YWx1ZSBvZiBEVCBpcyBwbGFjZWQgaW50byBWeC5cbiAgICBmdW5jdGlvbiBsb2FkRGVsYXlUaW1lciAoKSB7XG4gICAgICB2UmVnaXN0ZXJzW2luc3QueF0gPSBkZWxheVRpbWVyXG4gICAgfVxuXG4gICAgLy8gRngxNSAtIExEIERULCBWeCAtPiBEVCBpcyBzZXQgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIFZ4LlxuICAgIGZ1bmN0aW9uIHNldERlbGF5VGltZXIgKCkge1xuICAgICAgZGVsYXlUaW1lciA9IHZSZWdpc3RlcnNbaW5zdC54XVxuICAgIH1cblxuICAgIC8vIEZ4MUUgLSBBREQgSSwgVnggLT4gU2V0IEkgPSBJICsgVnguXG4gICAgZnVuY3Rpb24gYWRkSVZ4ICgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaVJlZ2lzdGVyICsgdlJlZ2lzdGVyc1tpbnN0LnhdXG5cbiAgICAgIGlmICh2YWx1ZSA+IDB4RkZGKSB7XG4gICAgICAgIHZSZWdpc3RlcnNbMHhGXSA9IDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZSZWdpc3RlcnNbMHhGXSA9IDBcbiAgICAgIH1cblxuICAgICAgaVJlZ2lzdGVyID0gdmFsdWUgJiAweEZGRlxuICAgIH1cblxuICAgIC8vIEZ4MjkgLSBMRCBGLCBWeCAtPiBTZXQgSSA9IGxvY2F0aW9uIG9mIHNwcml0ZSBmb3IgZGlnaXQgVnguXG4gICAgZnVuY3Rpb24gbG9hZElWeCAoKSB7XG4gICAgICBpUmVnaXN0ZXIgPSB2UmVnaXN0ZXJzW2luc3QueF0gKiA1XG4gICAgfVxuXG4gICAgLy8gRngzMyAtIExEIEIsIFZ4XG4gICAgLy8gU3RvcmUgQkNEIHJlcHJlc2VudGF0aW9uIG9mIFZ4IGluIG1lbW9yeSBsb2NhdGlvbnMgSSwgSSsxLCBhbmQgSSsyLlxuICAgIC8vIFRoZSBpbnRlcnByZXRlciB0YWtlcyB0aGUgZGVjaW1hbCB2YWx1ZSBvZiBWeCwgYW5kIHBsYWNlcyB0aGUgaHVuZHJlZHMgZGlnaXQgaW5cbiAgICAvLyBtZW1vcnkgYXQgbG9jYXRpb24gaW4gSSwgdGhlIHRlbnMgZGlnaXQgYXQgbG9jYXRpb24gSSsxLCBhbmQgdGhlIG9uZXMgZGlnaXQgYXQgbG9jYXRpb24gSSsyLlxuICAgIGZ1bmN0aW9uIHN0b3JlQmNkICgpIHtcbiAgICAgIGNvbnN0IGRlYyA9IHZSZWdpc3RlcnNbaW5zdC54XVxuXG4gICAgICAvLyBGb3IgYSBnaXZlbiB2YWx1ZSwgc2F5IDIzNFxuICAgICAgbWVtb3J5W2lSZWdpc3Rlcl0gPSBNYXRoLmZsb29yKGRlYyAvIDEwMCkgLy8gR2l2ZXMgdXMgMlxuICAgICAgbWVtb3J5W2lSZWdpc3RlciArIDFdID0gTWF0aC5mbG9vcihkZWMgLyAxMCkgJSAxMCAvLyBHaXZlcyB1cyAzXG4gICAgICBtZW1vcnlbaVJlZ2lzdGVyICsgMl0gPSBkZWMgJSAxMCAvLyBHaXZlcyB1cyA0XG4gICAgfVxuXG4gICAgLy8gRng1NSAtIExEIFtJXSwgVnggLT4gVlswXS4uLlZbeF0gPT4gbWVtb3J5W0ldLi4ubWVtb3J5W0kgKyB4XVxuICAgIGZ1bmN0aW9uIGxvYWRJVjBUb1Z4ICgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGluc3QueDsgaSArPSAxKSB7XG4gICAgICAgIG1lbW9yeVtpUmVnaXN0ZXIgKyBpXSA9IHZSZWdpc3RlcnNbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGeDY1IC0gTEQgVngsIFtJXSAtPiBUaGUgaW50ZXJwcmV0ZXIgcmVhZHMgdmFsdWVzIGZyb20gbWVtb3J5IHN0YXJ0aW5nIGF0IGxvY2F0aW9uIEkgaW50byByZWdpc3RlcnMgVjAgdGhyb3VnaCBWeC5cbiAgICBmdW5jdGlvbiBsb2FkVjBUb1Z4SSAoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpbnN0Lng7IGkgKz0gMSkge1xuICAgICAgICB2UmVnaXN0ZXJzW2ldID0gbWVtb3J5W2lSZWdpc3RlciArIGldXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRngwQSAtIExEIFZ4LCBLXG4gICAgLy8gV2FpdCBmb3IgYSBrZXkgcHJlc3MsIHN0b3JlIHRoZSB2YWx1ZSBvZiB0aGUga2V5IGluIFZ4LlxuICAgIC8vIEFsbCBleGVjdXRpb24gc3RvcHMgdW50aWwgYSBrZXkgaXMgcHJlc3NlZCwgdGhlbiB0aGUgdmFsdWUgb2YgdGhhdCBrZXkgaXMgc3RvcmVkIGluIFZ4LlxuICAgIGZ1bmN0aW9uIHdhaXRGb3JLZXlQcmVzcyAoKSB7XG4gICAgICBjb25zdCBrZXlQcmVzc2VkID0ga2V5Ym9hcmQuZ2V0QW55KClcblxuICAgICAgaWYgKCFrZXlQcmVzc2VkKSB7XG4gICAgICAgIHBjIC09IDIgLy8ga2VlcCBsb29waW5nIHVudGlsIGEga2V5IGlzIHByZXNzZWRcblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdlJlZ2lzdGVyc1tpbnN0LnhdID0ga2V5UHJlc3NlZFxuXG4gICAgICByZXR1cm4ga2V5UHJlc3NlZFxuICAgIH1cblxuICAgIC8vIEZ4MTggLSBMRCBTVCwgVnggLT4gU2V0IHNvdW5kIHRpbWVyID0gVnguXG4gICAgZnVuY3Rpb24gc2V0U291bmRUaW1lciAoKSB7XG4gICAgICBzb3VuZFRpbWVyID0gdlJlZ2lzdGVyc1tpbnN0LnhdXG4gICAgfVxuXG4gICAgcmV0dXJuIG1pY3JvT3BDb2Rlc1tpbnN0LmtrXSgpXG4gIH1cblxuICBmdW5jdGlvbiBnZXREcmF3RmxhZyAoKSB7XG4gICAgcmV0dXJuIGRyYXdGbGFnXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGN5Y2xlLFxuICAgIGdldERyYXdGbGFnLFxuICAgIGdldERpc3BsYXksXG4gICAgc2V0TWVtb3J5LFxuICAgIHJlc2V0XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/chip-8.js\n");

/***/ }),

/***/ "./src/keyboard.js":
/*!*************************!*\
  !*** ./src/keyboard.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst keyMap = {\n  '1': '1',\n  '2': '2',\n  '3': '3',\n  '4': 'q',\n  '5': 'w',\n  '6': 'e',\n  '7': 'a',\n  '8': 's',\n  '9': 'd',\n  'a': 'z',\n  '0': 'x',\n  'b': 'c',\n  'c': '4',\n  'd': 'r',\n  'e': 'f',\n  'f': 'v'\n}\n\nconst keys = {\n  '1': false,\n  '2': false,\n  '3': false,\n  'q': false,\n  'w': false,\n  'e': false,\n  'a': false,\n  's': false,\n  'd': false,\n  'z': false,\n  'x': false,\n  'c': false,\n  '4': false,\n  'r': false,\n  'f': false,\n  'v': false\n}\n\nfunction set (keyPress, value) {\n  keys[keyPress] = value\n}\n\nfunction get (hexKey) {\n  return keys[keyMap[hexKey.toString(16)]]\n}\n\nfunction getAny () {\n  return Object.values(keys).reduce((key, current, index) => {\n    const vmKey = Object.keys(keyMap)[index]\n    if (key) {\n      return key\n    } else if (current) {\n      return vmKey\n    }\n  }, null)\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  keyMap,\n  set,\n  get,\n  getAny\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMva2V5Ym9hcmQuanM/MThlMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEMiLCJmaWxlIjoiLi9zcmMva2V5Ym9hcmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBrZXlNYXAgPSB7XG4gICcxJzogJzEnLFxuICAnMic6ICcyJyxcbiAgJzMnOiAnMycsXG4gICc0JzogJ3EnLFxuICAnNSc6ICd3JyxcbiAgJzYnOiAnZScsXG4gICc3JzogJ2EnLFxuICAnOCc6ICdzJyxcbiAgJzknOiAnZCcsXG4gICdhJzogJ3onLFxuICAnMCc6ICd4JyxcbiAgJ2InOiAnYycsXG4gICdjJzogJzQnLFxuICAnZCc6ICdyJyxcbiAgJ2UnOiAnZicsXG4gICdmJzogJ3YnXG59XG5cbmNvbnN0IGtleXMgPSB7XG4gICcxJzogZmFsc2UsXG4gICcyJzogZmFsc2UsXG4gICczJzogZmFsc2UsXG4gICdxJzogZmFsc2UsXG4gICd3JzogZmFsc2UsXG4gICdlJzogZmFsc2UsXG4gICdhJzogZmFsc2UsXG4gICdzJzogZmFsc2UsXG4gICdkJzogZmFsc2UsXG4gICd6JzogZmFsc2UsXG4gICd4JzogZmFsc2UsXG4gICdjJzogZmFsc2UsXG4gICc0JzogZmFsc2UsXG4gICdyJzogZmFsc2UsXG4gICdmJzogZmFsc2UsXG4gICd2JzogZmFsc2Vcbn1cblxuZnVuY3Rpb24gc2V0IChrZXlQcmVzcywgdmFsdWUpIHtcbiAga2V5c1trZXlQcmVzc10gPSB2YWx1ZVxufVxuXG5mdW5jdGlvbiBnZXQgKGhleEtleSkge1xuICByZXR1cm4ga2V5c1trZXlNYXBbaGV4S2V5LnRvU3RyaW5nKDE2KV1dXG59XG5cbmZ1bmN0aW9uIGdldEFueSAoKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGtleXMpLnJlZHVjZSgoa2V5LCBjdXJyZW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHZtS2V5ID0gT2JqZWN0LmtleXMoa2V5TWFwKVtpbmRleF1cbiAgICBpZiAoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5XG4gICAgfSBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICByZXR1cm4gdm1LZXlcbiAgICB9XG4gIH0sIG51bGwpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAga2V5TWFwLFxuICBzZXQsXG4gIGdldCxcbiAgZ2V0QW55XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/keyboard.js\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _chip_8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chip-8 */ \"./src/chip-8.js\");\n/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard */ \"./src/keyboard.js\");\n\n\n\nconst SCALE = 10\n\nlet game\n\nfunction loadMemory (file) {\n  const array = new Uint8Array(file)\n\n  chip8.setMemory(array, 0x200)\n\n  game = new Phaser.Game(config)\n}\n\nwindow.addEventListener('keydown', ({ key }) => {\n  if (Object.values(_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"default\"].keyMap).includes(key)) {\n    _keyboard__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(key, true)\n  }\n})\n\ndocument.querySelectorAll('.game-controls__button').forEach(el => el.addEventListener('mousedown', event => {\n  const key = event.target.innerHTML\n  if (Object.values(_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"default\"].keyMap).includes(key)) {\n    _keyboard__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(key, true)\n  }\n}))\n\nwindow.addEventListener('keyup', ({ key }) => {\n  _keyboard__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(key, false)\n})\n\ndocument.querySelectorAll('.game-controls__button').forEach(el => el.addEventListener('mouseup', event => {\n  const key = event.target.innerHTML\n  _keyboard__WEBPACK_IMPORTED_MODULE_1__[\"default\"].set(key, false)\n}))\n\nconst sound = new Audio('./sound.wav')\n\nconst chip8 = Object(_chip_8__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"default\"], sound)\n\nfunction reset () {\n  if (game) {\n    game.canvas.remove()\n    game.scene.stop()\n    game.destroy()\n  }\n\n  chip8.reset()\n}\n\ndocument.getElementById('reset').addEventListener('click', _ => reset())\n\nfunction getGame (game) {\n  fetch(`./games/${game}`)\n    .then(response => response.blob())\n    .then(body => {\n      const reader = new FileReader()\n      reader.addEventListener(\"loadend\", _ => loadMemory(reader.result))\n      reader.readAsArrayBuffer(body)\n    })\n}\n\ndocument.getElementById('game-picker').addEventListener('change', event => {\n  reset()\n  getGame(event.target.value)\n}, false)\n\nconst Scene = new Phaser.Class({\n  Extends: Phaser.Scene,\n  initialize: function Scene () {\n    Phaser.Scene.call(this, { key: 'example' })\n  },\n  create: create,\n  applyPipeline: applyPipeline,\n  update: update\n})\n\nconst config = {\n  type: Phaser.AUTO,\n  width: 640,\n  height: 320,\n  parent: 'game',\n  scene: [ Scene ]\n}\n\nfunction create () {\n  const DISPLAY_WIDTH = chip8.getDisplay().length\n  const DISPLAY_HEIGHT = chip8.getDisplay()[0].length\n\n  const phaserDisplay = new Array(DISPLAY_WIDTH).fill().map(_ => new Array(DISPLAY_HEIGHT).fill(0))\n\n  for (let x = 0; x < phaserDisplay.length; x += 1) {\n    for (let y = 0; y < phaserDisplay[x].length; y += 1) {\n      phaserDisplay[x][y] = new Phaser.Geom.Rectangle(x * SCALE, y * SCALE, SCALE, SCALE)\n    }\n  }\n\n  this.phaserDisplay = phaserDisplay\n  this.graphics = this.add.graphics({ fillStyle: { color: 0xffffff }})\n  this.pipeline = this.game.renderer.addPipeline('Pipeline', new Pipeline(this.game))\n  this.applyPipeline()\n}\n\nfunction update (_, delta) {\n  const cpuSpeed = 1000 / 500 // 500Mhz\n  // cycle the CPU \"many\" times, depending on how long the draw loop took\n  const cycles = Math.floor(delta / cpuSpeed)\n  for (var i = 0; i < cycles; i += 1) {\n    chip8.cycle(delta)\n  }\n\n  if (chip8.getDrawFlag()) {\n    this.graphics.clear()  \n    const display = chip8.getDisplay()\n    for (var x = 0; x < display.length; x += 1) {\n      for (var y = 0; y < display[0].length; y += 1) {\n        const pixel = display[x][y]\n        this.graphics.fillStyle(pixel ? 0xffffff : 0x0)\n        const rect = this.phaserDisplay[x][y]\n        this.graphics.fillRectShape(rect)\n      }\n    }\n    chip8.drawFlag = false\n  }\n}\n\nfunction applyPipeline () {\n  this.cameras.main.setRenderToTexture(this.pipeline)\n}\n\nconst shader = `\n  precision mediump float;\n\n  uniform float time;\n  uniform vec2 resolution;\n  uniform sampler2D uMainSampler;\n\n  varying vec2 outTexCoord;\n\n  vec2 crt (vec2 coord) {\n    // lower == more curved\n    float straightness = 2.1;\n\n    // put in symmetrical coords\n    coord = coord - 0.5;\n\n    // shrink\n    coord *= 1.1;\t\n\n    // deform coords\n    coord.x *= 1.0 + pow(coord.y / (straightness + 0.5), 2.0);\n    coord.y *= 1.0 + pow(coord.x / straightness, 2.0);\n\n    // transform back to 0.0 - 1.0 space\n    coord  = coord + 0.5;\n\n    return coord;\n  }\n\n  void main () {\n    vec2 crtCoords = crt(outTexCoord);\n\n    if (crtCoords.x < 0.0 || crtCoords.x > 1.0 || crtCoords.y < 0.0 || crtCoords.y > 1.0) {\n      gl_FragColor.rgb = vec3(0.85, 0.85, 0.65);\n      return;\n    }\n\n    gl_FragColor = texture2D(uMainSampler, crtCoords);\n  }\n`\n\nconst Pipeline = new Phaser.Class({\n  Extends: Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline,\n  initialize: function Pipeline (game) {\n    Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline.call(this, {\n      game: game,\n      renderer: game.renderer,\n      fragShader: shader\n    })\n  }\n})//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUE0QjtBQUNLOztBQUVqQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLE1BQU07QUFDM0Msb0JBQW9CLGlEQUFRO0FBQzVCLElBQUksaURBQVE7QUFDWjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLG9CQUFvQixpREFBUTtBQUM1QixJQUFJLGlEQUFRO0FBQ1o7QUFDQSxDQUFDOztBQUVELG1DQUFtQyxNQUFNO0FBQ3pDLEVBQUUsaURBQVE7QUFDVixDQUFDOztBQUVEO0FBQ0E7QUFDQSxFQUFFLGlEQUFRO0FBQ1YsQ0FBQzs7QUFFRDs7QUFFQSxjQUFjLHVEQUFLLENBQUMsaURBQVE7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQiwwQkFBMEI7QUFDM0MsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsYUFBYSxtQkFBbUI7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vc3JjL21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hpcDggZnJvbSAnLi9jaGlwLTgnXG5pbXBvcnQga2V5Ym9hcmQgZnJvbSAnLi9rZXlib2FyZCdcblxuY29uc3QgU0NBTEUgPSAxMFxuXG5sZXQgZ2FtZVxuXG5mdW5jdGlvbiBsb2FkTWVtb3J5IChmaWxlKSB7XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZmlsZSlcblxuICBjaGlwOC5zZXRNZW1vcnkoYXJyYXksIDB4MjAwKVxuXG4gIGdhbWUgPSBuZXcgUGhhc2VyLkdhbWUoY29uZmlnKVxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsICh7IGtleSB9KSA9PiB7XG4gIGlmIChPYmplY3QudmFsdWVzKGtleWJvYXJkLmtleU1hcCkuaW5jbHVkZXMoa2V5KSkge1xuICAgIGtleWJvYXJkLnNldChrZXksIHRydWUpXG4gIH1cbn0pXG5cbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5nYW1lLWNvbnRyb2xzX19idXR0b24nKS5mb3JFYWNoKGVsID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGV2ZW50ID0+IHtcbiAgY29uc3Qga2V5ID0gZXZlbnQudGFyZ2V0LmlubmVySFRNTFxuICBpZiAoT2JqZWN0LnZhbHVlcyhrZXlib2FyZC5rZXlNYXApLmluY2x1ZGVzKGtleSkpIHtcbiAgICBrZXlib2FyZC5zZXQoa2V5LCB0cnVlKVxuICB9XG59KSlcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKHsga2V5IH0pID0+IHtcbiAga2V5Ym9hcmQuc2V0KGtleSwgZmFsc2UpXG59KVxuXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZ2FtZS1jb250cm9sc19fYnV0dG9uJykuZm9yRWFjaChlbCA9PiBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZXZlbnQgPT4ge1xuICBjb25zdCBrZXkgPSBldmVudC50YXJnZXQuaW5uZXJIVE1MXG4gIGtleWJvYXJkLnNldChrZXksIGZhbHNlKVxufSkpXG5cbmNvbnN0IHNvdW5kID0gbmV3IEF1ZGlvKCcuL3NvdW5kLndhdicpXG5cbmNvbnN0IGNoaXA4ID0gQ2hpcDgoa2V5Ym9hcmQsIHNvdW5kKVxuXG5mdW5jdGlvbiByZXNldCAoKSB7XG4gIGlmIChnYW1lKSB7XG4gICAgZ2FtZS5jYW52YXMucmVtb3ZlKClcbiAgICBnYW1lLnNjZW5lLnN0b3AoKVxuICAgIGdhbWUuZGVzdHJveSgpXG4gIH1cblxuICBjaGlwOC5yZXNldCgpXG59XG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXNldCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgXyA9PiByZXNldCgpKVxuXG5mdW5jdGlvbiBnZXRHYW1lIChnYW1lKSB7XG4gIGZldGNoKGAuL2dhbWVzLyR7Z2FtZX1gKVxuICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJsb2IoKSlcbiAgICAudGhlbihib2R5ID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVuZFwiLCBfID0+IGxvYWRNZW1vcnkocmVhZGVyLnJlc3VsdCkpXG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYm9keSlcbiAgICB9KVxufVxuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZS1waWNrZXInKS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBldmVudCA9PiB7XG4gIHJlc2V0KClcbiAgZ2V0R2FtZShldmVudC50YXJnZXQudmFsdWUpXG59LCBmYWxzZSlcblxuY29uc3QgU2NlbmUgPSBuZXcgUGhhc2VyLkNsYXNzKHtcbiAgRXh0ZW5kczogUGhhc2VyLlNjZW5lLFxuICBpbml0aWFsaXplOiBmdW5jdGlvbiBTY2VuZSAoKSB7XG4gICAgUGhhc2VyLlNjZW5lLmNhbGwodGhpcywgeyBrZXk6ICdleGFtcGxlJyB9KVxuICB9LFxuICBjcmVhdGU6IGNyZWF0ZSxcbiAgYXBwbHlQaXBlbGluZTogYXBwbHlQaXBlbGluZSxcbiAgdXBkYXRlOiB1cGRhdGVcbn0pXG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgdHlwZTogUGhhc2VyLkFVVE8sXG4gIHdpZHRoOiA2NDAsXG4gIGhlaWdodDogMzIwLFxuICBwYXJlbnQ6ICdnYW1lJyxcbiAgc2NlbmU6IFsgU2NlbmUgXVxufVxuXG5mdW5jdGlvbiBjcmVhdGUgKCkge1xuICBjb25zdCBESVNQTEFZX1dJRFRIID0gY2hpcDguZ2V0RGlzcGxheSgpLmxlbmd0aFxuICBjb25zdCBESVNQTEFZX0hFSUdIVCA9IGNoaXA4LmdldERpc3BsYXkoKVswXS5sZW5ndGhcblxuICBjb25zdCBwaGFzZXJEaXNwbGF5ID0gbmV3IEFycmF5KERJU1BMQVlfV0lEVEgpLmZpbGwoKS5tYXAoXyA9PiBuZXcgQXJyYXkoRElTUExBWV9IRUlHSFQpLmZpbGwoMCkpXG5cbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwaGFzZXJEaXNwbGF5Lmxlbmd0aDsgeCArPSAxKSB7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBwaGFzZXJEaXNwbGF5W3hdLmxlbmd0aDsgeSArPSAxKSB7XG4gICAgICBwaGFzZXJEaXNwbGF5W3hdW3ldID0gbmV3IFBoYXNlci5HZW9tLlJlY3RhbmdsZSh4ICogU0NBTEUsIHkgKiBTQ0FMRSwgU0NBTEUsIFNDQUxFKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMucGhhc2VyRGlzcGxheSA9IHBoYXNlckRpc3BsYXlcbiAgdGhpcy5ncmFwaGljcyA9IHRoaXMuYWRkLmdyYXBoaWNzKHsgZmlsbFN0eWxlOiB7IGNvbG9yOiAweGZmZmZmZiB9fSlcbiAgdGhpcy5waXBlbGluZSA9IHRoaXMuZ2FtZS5yZW5kZXJlci5hZGRQaXBlbGluZSgnUGlwZWxpbmUnLCBuZXcgUGlwZWxpbmUodGhpcy5nYW1lKSlcbiAgdGhpcy5hcHBseVBpcGVsaW5lKClcbn1cblxuZnVuY3Rpb24gdXBkYXRlIChfLCBkZWx0YSkge1xuICBjb25zdCBjcHVTcGVlZCA9IDEwMDAgLyA1MDAgLy8gNTAwTWh6XG4gIC8vIGN5Y2xlIHRoZSBDUFUgXCJtYW55XCIgdGltZXMsIGRlcGVuZGluZyBvbiBob3cgbG9uZyB0aGUgZHJhdyBsb29wIHRvb2tcbiAgY29uc3QgY3ljbGVzID0gTWF0aC5mbG9vcihkZWx0YSAvIGNwdVNwZWVkKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGN5Y2xlczsgaSArPSAxKSB7XG4gICAgY2hpcDguY3ljbGUoZGVsdGEpXG4gIH1cblxuICBpZiAoY2hpcDguZ2V0RHJhd0ZsYWcoKSkge1xuICAgIHRoaXMuZ3JhcGhpY3MuY2xlYXIoKSAgXG4gICAgY29uc3QgZGlzcGxheSA9IGNoaXA4LmdldERpc3BsYXkoKVxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgZGlzcGxheS5sZW5ndGg7IHggKz0gMSkge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBkaXNwbGF5WzBdLmxlbmd0aDsgeSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHBpeGVsID0gZGlzcGxheVt4XVt5XVxuICAgICAgICB0aGlzLmdyYXBoaWNzLmZpbGxTdHlsZShwaXhlbCA/IDB4ZmZmZmZmIDogMHgwKVxuICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5waGFzZXJEaXNwbGF5W3hdW3ldXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZmlsbFJlY3RTaGFwZShyZWN0KVxuICAgICAgfVxuICAgIH1cbiAgICBjaGlwOC5kcmF3RmxhZyA9IGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlQaXBlbGluZSAoKSB7XG4gIHRoaXMuY2FtZXJhcy5tYWluLnNldFJlbmRlclRvVGV4dHVyZSh0aGlzLnBpcGVsaW5lKVxufVxuXG5jb25zdCBzaGFkZXIgPSBgXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gIHVuaWZvcm0gZmxvYXQgdGltZTtcbiAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVNYWluU2FtcGxlcjtcblxuICB2YXJ5aW5nIHZlYzIgb3V0VGV4Q29vcmQ7XG5cbiAgdmVjMiBjcnQgKHZlYzIgY29vcmQpIHtcbiAgICAvLyBsb3dlciA9PSBtb3JlIGN1cnZlZFxuICAgIGZsb2F0IHN0cmFpZ2h0bmVzcyA9IDIuMTtcblxuICAgIC8vIHB1dCBpbiBzeW1tZXRyaWNhbCBjb29yZHNcbiAgICBjb29yZCA9IGNvb3JkIC0gMC41O1xuXG4gICAgLy8gc2hyaW5rXG4gICAgY29vcmQgKj0gMS4xO1x0XG5cbiAgICAvLyBkZWZvcm0gY29vcmRzXG4gICAgY29vcmQueCAqPSAxLjAgKyBwb3coY29vcmQueSAvIChzdHJhaWdodG5lc3MgKyAwLjUpLCAyLjApO1xuICAgIGNvb3JkLnkgKj0gMS4wICsgcG93KGNvb3JkLnggLyBzdHJhaWdodG5lc3MsIDIuMCk7XG5cbiAgICAvLyB0cmFuc2Zvcm0gYmFjayB0byAwLjAgLSAxLjAgc3BhY2VcbiAgICBjb29yZCAgPSBjb29yZCArIDAuNTtcblxuICAgIHJldHVybiBjb29yZDtcbiAgfVxuXG4gIHZvaWQgbWFpbiAoKSB7XG4gICAgdmVjMiBjcnRDb29yZHMgPSBjcnQob3V0VGV4Q29vcmQpO1xuXG4gICAgaWYgKGNydENvb3Jkcy54IDwgMC4wIHx8IGNydENvb3Jkcy54ID4gMS4wIHx8IGNydENvb3Jkcy55IDwgMC4wIHx8IGNydENvb3Jkcy55ID4gMS4wKSB7XG4gICAgICBnbF9GcmFnQ29sb3IucmdiID0gdmVjMygwLjg1LCAwLjg1LCAwLjY1KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodU1haW5TYW1wbGVyLCBjcnRDb29yZHMpO1xuICB9XG5gXG5cbmNvbnN0IFBpcGVsaW5lID0gbmV3IFBoYXNlci5DbGFzcyh7XG4gIEV4dGVuZHM6IFBoYXNlci5SZW5kZXJlci5XZWJHTC5QaXBlbGluZXMuVGV4dHVyZVRpbnRQaXBlbGluZSxcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUGlwZWxpbmUgKGdhbWUpIHtcbiAgICBQaGFzZXIuUmVuZGVyZXIuV2ViR0wuUGlwZWxpbmVzLlRleHR1cmVUaW50UGlwZWxpbmUuY2FsbCh0aGlzLCB7XG4gICAgICBnYW1lOiBnYW1lLFxuICAgICAgcmVuZGVyZXI6IGdhbWUucmVuZGVyZXIsXG4gICAgICBmcmFnU2hhZGVyOiBzaGFkZXJcbiAgICB9KVxuICB9XG59KSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ })

/******/ });